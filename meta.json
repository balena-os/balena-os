{"slug":"balena-os","type":"repository","version":"1.6.3","markers":[],"tags":[],"links":{},"active":true,"data":{"license":"CC0-1.0","name":"balena-os","tagline":"The central place for all things BalenaOS related.","images":{"banner":"data:image/svg;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAAAqCAYAAADh9oTeAAAACXBIWXMAAAsTAAALEwEAmpwYAAAN7UlEQVR42u1dC3QU1Rm+1IKK4Nv6QBGtSLJBOAXFWhVa8XmAzCZtPJ5WK2ql8tiZDdklPNQgoKVWrDzMzgRa7SbxsdoKSqs9wuEVIGQ3BJUKqBDk6QsNIE/z6P/f2ezOztw7O7PZhQDzn3PPZGfu/HPnzv/d/3H/e0NIW2jVjDNJRBkFZQ2UvSQsfwfHKhIOPELWhzoRhxw66alWHkYi8hYQ/BZmCcufwrHA6SiHTk6qKf0ZCSvLuAAwAmIxqZ3bx+k4h04OWjP7AhDsmaAFGi2DIAYGpQnuC5J1pT9xOtKhE5PQ1o8oPigNXEGvkevJqtkryapZq0ADbOeDQt4D1z1kScmPnY516MShSNlQEN5NXMFeE9hMFkytIcFxzaTc30JLha+JLJy6mtQEtpqYSx8D77ucDnaonZtBZdeCwC7kj+yBBvL+s0tB8I/EAKAvFeOOQh3wJeS9JhrifXhWjtPhDrUv+rD0PBDQ6TBiH+Ha+itnV5FXx3/NBYC+vFK8hyx/YZmJb3EU+CpwvND5AA61g2iQch8I4zfc0bv6xbXkzSc2WgaAvuC9a0o/MDGXvnLCrQ4dZ19AEU2iPp+Tf09dmjIA9GXh1FoQ+h0mgHjM+SAOHR+qLruchjfDcrNGIL8ni59bSir8h9IGgng5Qv2HsLxf8zx8dojUvHiF80FOUaqdew3IgETlIKKsgIKD5ntwnEciZfeS6pln2zf15dFw/xtwrKH8IvICOBaRNXMu0WuDG0lLSwe1IfJA+L0WTJgN5LUJOzMAgMTy+oTtpCawCRq3Ep59PW0DhlYjyi2p9qXLLbXEiiAebE/fGdoUTGhfrvc3jvQDrQ30pQKqHYjZ1sL3UG+aJUCElTFQ9ifh5dUCYRfNFaqVb6K/W0p+RCrHPwSC+mXGgRD0bSdvTLhXA8TB0JaPqDnmAOEU0QLyCG5whh9t3E4zHLggkP9ig9fEVuQ0xUyTsFJO6gLd6PlQSRcQ1slQDqcfAP6DpNw3nczzd6XPWlZ2FbThrYRIkgOEU8A3lUtsZynEBXhfzIpItHDutMnrBzpdYLjwavEaKqQIBKRKf08Q3lAatcA75KXiHpR3sOgsCrYFU6p1L9noAOEUiFLyTKGwcphaKWFlERw3mgjxNrJ67sU6k+hdZkZDRH5e9YOjA3/i8542AqHcvzU6am+FEg9nlvsHQ/moDSBYSyqKBlJeJWB+BX3Dgf8uei00qT7TQOiV6+/qyvPc7crzjqYFhNA1VOxul//lBYVnZuWJd7gEaXiWII7KdnuEa4eOvTAjQCgoOC0rz/PzbLd4P7Y5W/A84HKLtwwalFqKiqtgVJesPO+QLEHyZgviIzl54g1wuoMdHtcNGXlejlscCu1/FNoyItst3dPnDhjQ7ND6OV2iJnmL4bujD1D30rmJoCntDdeXcMAwT6dl9hlTgJTbNRpjBgMI7/KBEC/VMHLfGHNkg/4RUKxPqJX7voGjREIFp6mAKroBfq9KqJNBIOCHA6EN4N8J12JFrEbBTsYXBOhS+OgKlAMGHoLUCOffRGDlCJ5faK/B+ZF2geAqKDwfrj8NwrqH1Wbg+S28z7S+gnQupw8e1dbPEbzDgNcMaOchBr8tCLSk/ZrrccH986HuD8b3Fw9mC9LsqwuKz8H3TXh2vvdmhknkZwp1rXy/SYi/I2iQd5imzdpAT00dhpYpuzXGB82gsFycUCJlw60AAYW5CUqQvDJBVUOhwvPh/EwY1X8wAcFRWidUfA695+XCbpRH0N9sqJshIMDHOQofro4NAL1widOppmJQtuC9lSeUBgF1i2PaAgSXu3AAtGWblTajEOfkjembDAjQD9stvL/M0w5ZudLv4f2PJG2PIG6C951iAQg1DIGuTB5d+ttF0cVfHIeXgmE3Y8T/Fso4UjWvq9lkmgUgxOz7/dSmn+k5XRVuXx84t5pRbxH1LVTQnAnCXwwg2MflmymNYLfAKGsQArd0E2ck5fCQGlMFQu9c7/UgtPvttBkB2jt/TJYZEGy8/28N/QkmIFxrTvX9DUDAVBrWqM1yfNkRoRcYIFqh4R8w8Skwc+JJg+llGwhxQf8k5j8oIzrSkV/1K5rhWklsZA0WDYPzW5LyyzAQULhAYJ5BQctyj76glyD1QHsbzn2sq9uc5fYM0trUcG6nbuRE0+BFtNV75Y6+LDt/1JWuXCkXeC3maAlLQKA+jFvcoXvWd2giIRjRNMtyi/2B3+PwrC91z/hf/xHwHUyAgICBev7sfLFn9jBvDvyeaACdIH2k7cteuVIvOH9Yx2sv3DcZ2tOv9zDxYspP9V3Ws97fAITauf0ZAtoQC6EnjTQpQxhzAjs11y+Npuu0mANC9iYuJ04FCPEwaHlMOwT9MhR1RMWwKEaHrPLJKBDEevxYrLr9h47orBdgEJaV8dFQLNLxO5zj9tzJeXQHuPf5VIGAwqVr93qeM99zSGE3FFqdEP/RDAjou+j55LilfH29awo8F/HaC23crdc+rXTlgw+eAf31n6RAYAkypvpbDrkq1zH9BC2Q6ASd8pmF0OkGcMR7tR0IKhj+SzUAagY8IjDKfWFbPDIKhMIBFpxgrQPcnCOMvUIVTrFKJ9STkkV59AJqAwifadvgyvPeho4+r9DIldZkEaSlXB/BLYaZ7YXvhcKdUBe0BV7CyBQIdoPe6TZ7fYyeocZIAgRGnF/+wgYQbmGGR431OsP5PzOjSHptQkOwbQWC6kx74mFW31Tb92fKWQaTwdI9gjRfN/K5o8KZaDoUjLokGS80OewCAUfhNvk2UZPFxFl+2aS/FrEE97p879V6bWAl1Ap9+bopENRQKEsou1sEQhHj3g+59dEfoJEhVrg25kzPSRcQ1sUeHPTtbD9AEJdYuQeEdZb2vizB+wc6Iiby+t4KL4yw2AUCjsJpAAIAtaQTBwizrQ4COYJ0V1RT9tM50qss9uVzpkAIhU6Db/w1QxgnJ2WO6T8ReT1DI8xOeu8nM08nNcrDVPswTbO0AMF/lJpFali1pb0AAf0Dixrh9UTh9dxr0AiC2GRl4gieOd4uENAUaysIMHTLN42kWSbtfSuBV57nbtV/8PxUHxq1BARBfCVp+DSs/J0xMh8A296VJGI0ljP/MFi9HhCiodJ4wSTSxNymwQwgHEoXEFqIUtKZ/KO4e/sCAghBrjTQrH50Euhb7T3XDhtzVVRIqhMFV3woyeM7gMDU2gUCah/9PAX4APeheWK55HkuTycQMAoF1/Yltsnbz+zlcYJP35fseQQli7NicXfC5FdME4AjjFEeZnqEvDrmKLP9j0ZSO+8yc2ddaWABof7YA2HilowBQRA3o0Ns4ty+yosaoXOsD0GyJrA0UaYnUo0agdDN1Y3AtTjDzIvQZOd6b48Vt3QPhoTTCYSopgzp3v9jDJly+9ItvpY0ahQXyFkc57WZ7oUVlh+H3yPh+Iy62QNnmW9r1jQSOr2sOQoES0T5FRQ3gKmeAZaVRiBUjl93zIEw/6m6DM8j7MZcndZoEJo4+MHh/Aqj4KpmkTqZNvoC/aiIESaM5aPpoM41lHTCfCC90NgGwlCxO/ohunZ/hhNarcKHgMZJL0NkCkw4rYCmDQjuwgGGyTRB3IWh2tbAAfYl+hX6CJsFIHS0tVEc28kdwzC7FqXAq4jQGKz25IIpS445EJY+v8Rosx2PmWUplMz5TcF2tzyz7MqTCvQzsxZmg5vQjDJNsUgRCFGbf0Zb3p8LBCRMeTDdLYWbgt1II0HM9Q1z+9tc37BZTb3APxIW6Zd+Ryp8248ZEF6b+Dljy5eNaYoaLYBjxKJALcSZZGYkSJC8KHAWhP6A3jyynWuEWbG6WLxJmxvY+UrpAwL1X9ySYk3wxR36SUVTILQmcoaVSUnj/XEz5wNwin9p7lSj04wr0JLy2hp30NWtVBIrVM2qJxX+TzMOBNzZgrURGI3rpkUjBFuzT5lZkypYttFZ2YJodiwvLIo5R25xOW9UBj5v4wx2OrJP0VnH2D8mDfIAh8KpdZAzBQQtQKE9Gzia9BBojjKcULOUfcoi3A5U3VGxKroeQb/DSSWpUX5NQ6hWCBeY4RqEsPKJwQeJyHU0UQ/TwTWqJJuaIoYc7sAR8s60xSTo25t2IFSObyDLXlhOnR1WGI2uGEqNtLOv2nAnTW3G0ZamTYglILiPYe6R3Xx8astjbo0gFcPHfwpNJ0x50I6g2jZcc3c0BSVqT2uvtcb9eQT3nk1TqN2ihM+C5/qoY5zr75rkvtO1z8FUErM1Cgl1NTlL7Jl4sTe04eGo5nsS0zTwPt6zU107QZPz6gI96L8eaCutC55FJ+xwkwqcT+A/tGw4dwOu6tKvyD+fXESC/sY0AKGJvPunakDlN9xlc5Gy3xGHHDpuhKt4cNE8z55a9tcNphGlZED41+Q6dccKbgSgnoa4HHLouBOqIZqXYeK4LHq2hpSP22YZCLgtDG4TyXdaDtDp9XSoQIccSiupjkaQv7haPkgW4O53dKEOGwiVxeoGYSz/Q7uhl9VkK4ccOm4UDtwMAhvhjuar5+wioUlVAIhDMSBUjjtA3pu+HO77wiRstZpuLOaQQycMYbiKZu0x1oLGNwhuIG8rnel2jdptHI1+wA66QNvqaiSHHGp3hCEotOV5pg5dCAFmDvvaQbrdvOniaYccOpFI3ag1ZBkIuAVHddlVTsc5dHJSpOw2Ot3NB0It3VTYIYdOesI8kRrlAZo4teSlM+gOAhFlPv2HH1anwh1yqB3Q/wEfuP1vE0k0HwAAAABJRU5ErkJggg==","bannerText":"8@ balena\n"},"description":"The central place for all things BalenaOS related.","version":"1.6.3","type":"npm","links":{"issueTracker":null,"homepage":"","repository":"https://github.com/balena-os/balena-os.git"},"maintainers":[],"changelog":[],"faq":null,"contributing":{"architecture":null,"guide":{"filename":"CONTRIBUTING.md","mime":"text/markdown","title":"Running locally","data":{"markdown":"Thanks for your interest in contributing to this project! This document aims to serve as a friendly guide for making your first contribution.\n\n# Running locally\n\nInstall all dependencies\n```\nnpm i\n```\n\nBuild and run the site\n```\nnpm run dev\n```\n\nIf you get rate limited by Github, you can pass a Github token.\n\n```\nGH_TOKEN=**** npm run dev\n```\n\n# Deploying\n\nAfter a PR has been created, a member of the balena team will review and merge into master.\n\nShortly after merging to master it'll automatically be deployed to our [staging environment](https://balena-os-staging.herokuapp.com/) (This should only take a few minutes).\n\nOnce deployed to staging, you can preview your changes. If everything looks good, a member of the balena team will make another PR from master into the production branch. When this is merged, the changes will automatically deploy to production.\n","jsonml":[["para","Thanks for your interest in contributing to this project! This document aims to serve as a friendly guide for making your first contribution."],["header",{"level":1},"Running locally"],["para","Install all dependencies\n",["inlinecode","\nnpm i\n"]],["para","Build and run the site\n",["inlinecode","\nnpm run dev\n"]],["para","If you get rate limited by Github, you can pass a Github token."],["para",["inlinecode","\nGH_TOKEN=**** npm run dev\n"]],["header",{"level":1},"Deploying"],["para","After a PR has been created, a member of the balena team will review and merge into master."],["para","Shortly after merging to master it'll automatically be deployed to our ",["link",{"href":"https://balena-os-staging.herokuapp.com/"},"staging environment"]," (This should only take a few minutes)."],["para","Once deployed to staging, you can preview your changes. If everything looks good, a member of the balena team will make another PR from master into the production branch. When this is merged, the changes will automatically deploy to production."]]}},"codeOfConduct":null,"security":null},"motivation":"![concept](./os-flow.png)\n\nIn our quest to build [balenaCloud](https://balena.io/cloud), a platform that brings the tools of modern software development to the world of connected hardware, we started by porting Docker to ARM chips in 2013. We soon realised that we also needed an operating system optimized for the use case: a minimal OS ideal for running containers on embedded devices. BalenaOS supports almost 20 distinct device types, has a robust networking and provisioning story, emphasizes reliability over long periods operation, and enables a productive developer workflow. We’ve been running balenaOS as part of the balenaCloud platform for years and are now releasing it as an independent operating system, so that others can benefit and contribute to running containers on connected devices.\n","introduction":"","hardwareRequired":"","softwareRequired":"","highlights":[{"title":"**Tailored for containers**","description":" Containers will revolutionize connected devices, and balenaOS is the best way to run them."},{"title":"**Built to last anywhere**","description":" Made to survive harsh networking conditions and unexpected shutdowns."},{"title":"**Just the essentials**","description":" A minimal Linux with the services needed to run Docker reliably on an embedded device - nothing else."},{"title":"**Easy to port**","description":" Based on Yocto Linux for easy porting to most capable device types across varied CPU architectures."},{"title":"**Fast, modern workflow**","description":" Who said embedded software has to be slow and painful to develop?"},{"title":"**Open and friendly**","description":" Actively developed in the open; community participation warmly welcomed."}],"readmeLeftover":"**Run Docker containers on embedded devices**\n\n## Contributing\n\nDo you want to help make balenaOs better? Take a look at our [Contributing Guide](https://balena.io/os/contributing). Hope to see you around!\n\n## License\n\nbalenaOs is free software, and may be redistributed under the terms specified in the [license](https://github.com/balena-os/balena-os/blob/master/LICENSE).\n\nLinks:\n\n-   [Feature request / Report a bug](https://github.com/balena-os/balena-os/issues)\n-   [Documentation](https://balena.io/os/)\n-   [meta-balena](https://github.com/balena-os/meta-balena) - _meta-balena is a Yocto layer used to build balena operating system images_\n-   [Contribute to balena.io/os website](/CONTRIBUTING.md)\n","screenshot":null,"installation":null,"isCli":false,"blog":[],"docs":{"latest":"1.6.3","tags":{"1.6.3":[{"filename":"docs/architecture.md","mime":"text/markdown","title":"Architecture Overview","data":{"markdown":"---\ntitle: Architecture\nlayout: docs.html\n---\n\n# Architecture Overview\n\n## Introduction\n\nBalenaOS is an operating system optimised for running Docker containers on embedded devices, with an emphasis on reliability over long periods of operation, as well as a productive developer workflow inspired by the lessons learned while building balena.\n\nThe core insight behind balenaOS is that Linux Containers offer, for the first time, a practical path to using virtualisation on embedded devices. VMs and hypervisors have lead to huge leaps in productivity and automation for cloud deployments, but their abstraction of hardware as well as their resource overhead and lack of hardware support means that they are out of the question for embedded scenarios. With OS-level virtualisation as implemented for Linux Containers, both those objections are lifted for Linux devices, of which there are many in the Internet of Things.\n\nBalenaOS is an operating system built for easy portability to multiple device types (via the Yocto framework) and optimised for Linux Containers, and Docker in particular. There are many decisions, large and small, we have made to enable that vision, which are present throughout our architecture.\n\nThe first version of balenaOS was developed as part of balena, and has run on thousands of embedded devices, deployed in many different contexts for several years. BalenaOS v2 represents the combination of the learnings we extracted over those years, as well as our determination to make balenaOS a first-class open source project, able to run as an independent operating system, for any context where embedded devices and containers intersect.\n\nWe look forward to working with the community to grow and mature balenaOS into an operating system with even broader device support, a broader operating envelope, and as always, taking advantage of the most modern developments in security and reliability.\n\n## OS composition\n\nThe OS is composed of multiple yocto layers. The [Yocto Project](https://www.yoctoproject.org/) build system uses these layers to compile balenaOS for the various [supported platforms](./supportedboards.md).\nThis document will not go into detailed explanation about how the [Yocto Project](https://www.yoctoproject.org/) works, but will require from the reader a basic understanding of its internals and release versioning/codename.\n\n| Codename | Yocto Project Version | Release Date | Current Version | Support Level | Poky Version | BitBake branch |\n|:--------:|:---------------------:|:------------:|:---------------:|:-------------:|:------------:|:--------------:|\n|   Pyro   |          2.3          |   Apr 2017   |                 |  Development  |              |                |\n|   Morty  |          2.2          |   Oct 2016   |      2.2.1      |     Stable    |     16.0     |      1.32      |\n|  Krogoth |          2.1          |   Apr 2016   |      2.1.2      |     Stable    |     15.0     |      1.30      |\n|  Jethro  |          2.0          |   Nov 2015   |      2.0.3      |   Community   |     14.0     |      1.28      |\n|   Fido   |          1.8          |   Apr 2015   |      1.8.2      |   Community   |     13.0     |      1.26      |\n|   Dizzy  |          1.7          |   Oct 2014   |      1.7.3      |   Community   |     12.0     |      1.24      |\n|   Daisy  |          1.6          |   Apr 2014   |      1.6.3      |   Community   |     11.0     |      1.22      |\n|   Dora   |          1.5          |   Oct 2013   |      1.5.4      |   Community   |     10.0     |      1.20      |\n\nWe will start looking into balenaOS’s composition from the core of the [Yocto Project](https://www.yoctoproject.org/), i.e. poky. Poky has released a whole bunch of versions and supporting all of them is not in the scope of our OS, but we do try to support its latest versions. This might sound ironic as we do not currently support poky’s last version (i.e. 2.1/Krogoth), but this is only because we did not need this version yet. We tend to support versions of poky based on what our supported boards require and also do a yearly update to the latest poky version for all the boards that can run that version. Currently we support three poky versions: 2.0/Jethro, 1.8/Fido and 1.6/Daisy.\n\nOn top of poky we add the collection of packages from meta-openembedded.\nNow that we are done with setting up the build system let’s add Board Support Packages (BSP), these layers are here to provide board-specific configuration and packages (e.g. bootloader, kernel), thus enabling building physical hardware (not emulators). These types of layers are the ones one should be looking for if one wants to add support for a board; if you already have this layer your job should be fairly straightforward, if you do not have it you might be looking into a very cumbersome job.\nAt this point we have all the bits and pieces in place to build an OS.\nThe core code of balenaOS resides in meta-balena. This layer handles a lot of functionality but the main thing that one should remember now is that here one will find the `balena-image.bb` recipe. This layer also needs a poky version-specific layer to combine with (e.g. meta-balena-jethro), these two layers will give you the necessary framework for the abstract balenaOS generation.\nNow for the final piece of the puzzle, the board-specific meta-balena configuration layer. This layer goes hand in hand with a BSP layer, for example for the Raspberry Pi family (i.e. rpi0, rpi1, rpi2, rpi3) that is supported by the meta-raspberrypi BSP, we provide a meta-balena-raspberrypi layer that configures meta-balena to the raspberrypi's needs.\n\nBelow is a representative example from the Raspberry Pi family, which helps explain [meta-balena-raspberrypi/conf/samples/bblayers.conf.sample](https://github.com/balena-os/balena-raspberrypi/blob/master/layers/meta-balena-raspberrypi/conf/samples/bblayers.conf.sample).\n\n| Layer Name                        | Repository                                                                      | Description                                                                           |\n|-----------------------------------|-------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|\n| meta-balena                        | https://github.com/balena-os/meta-balena                                        | This repository enables building balenaOS for various devices                         |\n| meta-balena-jethro                 | https://github.com/balena-os/meta-balena                                        | This layer enables building balenaOS for jethro supported BSPs                        |\n| meta-balena-raspberrypi            | https://github.com/balena-os/balena-raspberrypi                                 | Enables building balenaOS for chosen meta-raspberrypi machines.                        |\n| meta-raspberrypi                  | https://github.com/agherzan/meta-raspberrypi                                  | This is the general hardware specific BSP overlay for the Raspberry Pi device family. |\n| meta-openembedded                 | http://git.openembedded.org/meta-openembedded                                 | Collection of OpenEmbedded layers                                                     |\n| meta-openembedded/meta-oe         | https://github.com/openembedded/meta-openembedded/tree/master/meta-oe         |                                                                                       |\n| meta-openembedded/meta-python     | https://github.com/openembedded/meta-openembedded/tree/master/meta-python     | The home of python modules for OpenEmbedded.                                          |\n| meta-openembedded/meta-networking | https://github.com/openembedded/meta-openembedded/tree/master/meta-networking | Central point for networking-relatedpackages and configuration.                       |\n| oe-meta-go                        | https://github.com/mem/oe-meta-go                                             | OpenEmbedded layer for the Go programming language                                    |\n| poky/meta-yocto                   | https://git.yoctoproject.org/git/meta-yocto                                   |                                                                                       |\n| poky/meta                         | https://git.yoctoproject.org/git/poky                                         | Core functionality and configuration of Yocto Project                                 |\n\n\n\n## Userspace Components\nThe balenaOS userspace tries to package only the bare essentials for running containers while still offering a lot of flexibility. The philosophy is that software and services always default to being in a container, unless they are generically useful to all containers or they absolutely can’t live in a container.  The userspace consists of many open source components, but in this section we will just highlight some of the important ones.\n\n<img src=\"/images/docs/arch/userspace-components.png\" width=\"90%\">\n\n### Systemd\nWe use systemd as the init system for balenaOS and it is responsible for launching and managing all the other services. We leverage many of the great features of systemd, such as adjusting OOM scores for critical services and running services in separate mount namespaces. Systemd also allows us to easily manage service dependencies.\n\n### Docker\nThe Docker engine is a lightweight container runtime that allows us to build and run linux containers on balenaOS. BalenaOS has been optimized to run Docker containers and has been set up to use the journald log driver and DNSmasq for container DNS resolution.\nWe use AUFS as the underlying storage driver since it is arguably the most production tested storage driver in the Docker ecosystem. It also allows us to more easily support devices with older kernel versions and additionally gives us the ability to run on devices with Unmanaged NAND flash.\n\n### NetworkManager and ModemManager\nBalenaOS uses NetworkManager accompanied by ModemManager, to deliver a stable and reliable connection to the internet, be it via ethenet, wifi or cellular modem. Additionally to make headless configuration of the device’s network easy, we have added a `system-connections` folder in the boot partition which is copied into `/etc/NetworkManager/system-connections`. So any valid NetworkManager connection file can just be dropped into the boot partition before device commissioning.\n\n### DNSmasq\n\nDNSmasq is here to manage the nameservers that NetworkManager provides for balenaOS.\nNetworkManager will discover the nameservers that can be used and a binary called `resolvconf` will write them to a tmpfs location, from where DNSmasq will take over and manage these nameservers to give the user the fastest most responsive DNS resolution.\n\n### Avahi\nIn order to improve the development experience of balenaOS, there is an Avahi daemon that starts advertising the device as `balena.local` or `<hostname>.local` on boot if the image is a development image.\n\n### OpenVPN\n\nBalenaOS will provide the user with an OpenVPN server that they might use. It is worth noting that this server will be disabled by default and manual interaction from the user is needed to activate and configure this server to their needs.\n\n## Image Partition Layout\n\n<img src=\"/images/docs/arch/partition-layout.png\" width=\"90%\">\n\nThe first partition, resin-boot, is meant to hold boot important bits according to each board (e.g. kernel image, bootloader image). It also holds a very important file that you will find mentioned elsewhere in this document (i.e. `config.json`). The config.json file is the central point of configuring balenaOS and defining its behaviour, for example you can set your hostname, allow persistent logging, etc.\nResin-rootA is the partition that holds our read-only root filesystem; it holds almost everything that balenaOS is.\nResin-rootB is an empty partition that is only used when the rootfs is to be updated. We follow the Blue-Green deployment strategy. Essentially we have one active partition that is the OS’s current rootfs and one dormant one that is empty, we download the new rootfs to the dormant partition and try to switch them, if the switch is successful the dormant partition becomes the new rootfs, if not, we rollback to the old active partition.\nResin-state is the partition that holds persistent data as explained in the [Stateless and Read-only rootfs](#stateless-and-read-only-rootfs).\nResin-data is the partition that holds downloaded Docker images. Generally any container data will be found here.\n\n## Stateless and Read-Only rootFS\n\nBalenaOS comes with a read-only root filesystem, so we can ensure our hostOS is stateless, but we still need some data to be persistent over system reboots. We achieve this with a very simple mechanism, i.e. bind mounts.\nBalenaOS contains a partition named resin-state that is meant to hold all this persistent data, inside we populate a Linux filesystem hierarchy standard with the rootfs paths that we require to be persistent. After this partition is populated we are ready to bind mount the respective rootfs paths to this read-write location, thus allowing different components (e.g. journald) to be able to write data to disk. A mechanism to purge this partition is provided, thus allowing users to rollback to an unconfigured balenaOS image.\n\nA diagram of our read-only rootfs can be seen below:\n\n<img src=\"/images/docs/arch/read-only-rootfs.png\" width=\"90%\">\n\n## Dev vs. Prod images\nBalenaOS comes in two flavours, namely Development (dev) and Production (prod).\nThe Development images are recommended while getting started with balenaOS and building a system.\nThe dev images enable a number of useful features while developing, namely:\n\n* Passwordless SSH to balenaOS\n* The device broadcasts as balena.local or \\<hostname\\>.local on the network for easy access.\n* Docker socket exposed on via port 2377\n* Getty console attached to tty1 and serial\n\n__Note:__ Raspberry Pi devices don’t have Getty attached to serial.\n\nThe production images have all of the above functionality disabled by default. In both forms of the OS we write logs to an 8 MB journald RAM\nbuffer in order to avoid wear on the flash storage used by most of the supported boards. However, persistent logging can be enabled by setting\nthe `\"persistentLogging\": true` key in the `config.json` file in the boot partition of the device.\n\n## OS Tools\n\n### Base Images\n\nTo help getting started with containers on embedded systems, balenaOS comes with a full complement of over 500 Docker base images. We currently have base images for\nDebian, Fedora and Alpine Linux distributions, as well as Nodejs, Python, Go and Java language base images. For a more in-depth look into all the available base images head over\nto the [balena base images wiki](http://balena.io/docs/runtime/balena-base-images/) or the [Docker Hub repository](https://hub.docker.com/u/resin/).\n\n### Balena Command Line Tool\n\nThe balena CLI is a set of useful tools that help with setting up and developing containers with a balenaOS device. The goal of the CLI is to provide\na simple and intuitive developer experience. Currently, local mode part of the CLI are evolving fast and is considered 'beta', so as always, we love it when you report bugs,\nyou can report them here: [github.com/balena-io/balena-cli](https://github.com/balena-io/balena-cli)\n\n#### Installation\nCurrently the CLI is a node.js based command line tool which requires that our system has the following dependencies installed and in our path:\n\n* [node.js 6.x](https://nodejs.org/en/)\n* [npm package manager](https://www.npmjs.com/)\n* [rsync](https://download.samba.org/pub/rsync/rsync.html)\n* [ssh](http://www.openssh.com/)\n\nOnce we have those setup we can install the CLI using npm:\n``` bash\n$ npm install --global --production --unsafe-perm balena-cli\n```\n#### Usage\n##### Configure\n`balena local configure` allows you configure or reconfigure a balenaOS system image or SD card. Currently, this allows for configuration of wifi settings, hostname and enablement of\npersistent journald logs.\n\n``` bash\n$ balena help local configure\nUsage: local configure <target>\n\nUse this command to configure or reconfigure a balenaOS drive or image.\n\nExamples:\n\n\t$ balena local configure /dev/sdc\n\t$ balena local configure path/to/image.img\n```\n\n##### Flash\n`balena local flash` command helps to easily and safely flash the balenaOS system image on an SD card or USB drive.\n\n__Note:__ Currently, `balena local flash` doesn't work with the Intel Edison board.\n\n``` bash\n$ balena help local flash\nUsage: local flash <image>\n\nUse this command to flash a balenaOS image to a drive.\n\nExamples:\n\n\t$ balena local flash path/to/balenaos.img\n\t$ balena local flash path/to/balenaos.img --drive /dev/disk2\n\t$ balena local flash path/to/balenaos.img --drive /dev/disk2 --yes\n\nOptions:\n\n    --yes, -y                           confirm non-interactively          \n    --drive, -d <drive>                 drive     \n```\n\n##### Push\nThe `balena local push` command enables you to quickly build and deploy a Docker container to a target device. It also allows you to easily sync code between your laptop\ndirectory and your running container on the target. Once you have a balenaOS host device running and advertising on the network,\n`balena local push` will allow you to iterate code on a container service. `push` has a lot of advanced functionality, which all gets encoded into the `.balena-sync.yml` file in your\nproject directory. To better understand the `.yml` file, let's look at an example:\n\n```\n  app-name: myapp\n  build-triggers:\n    - Dockerfile: 9396730559c4107a0d82f95373c45d8e0634556342fb4ee276a7bc1c84c51570\n    - package.json: 1e40740d7cf5018cf887124ee75917eb139d49473c51464580feda247b3a4641\ndestination: /usr/src/app\nignore:\n  - .git\n  - node_modules/\n```\n\nLet's look a bit into some of these settings keys.\n\n* `app-name:` represents the name of the Docker image and corresponding running container on the target device.\n* `build-triggers:` is a list of file names and their content hashes. Any changes in the files contained in this list will result in a `docker build .` on the\ntarget device.\n* `destination:` this sets the destination sync directory in the container running on the device. This allows you to synchronise a `--source` directory on your laptop to a running\ncontainer on the device. This is very useful when developing with interpreted languages like Python or Node.js, as you can sync just your source code across, without rebuilding the\nentire container.\n* `ignore:` is a list of files or directories that you would like to be ignored during the directory sync. This is useful in the case where you have `node_modules` in your source\ndirectory that is compiled to run on your x86 laptop, but you are pushing your code over to an ARM based embedded device.\n\nThe push has quite a bit of functionality and a few useful flags. Check out the `balena help local push`:\n\n``` bash\n$ balena help local push\nUsage: local push [deviceIp]\n\nWarning: 'balena local push' requires an openssh-compatible client and 'rsync' to\nbe correctly installed in your shell environment. For more information (including\nWindows support) please check the README here: https://github.com/balena-io/balena-cli\n\nUse this command to push your local changes to a container on a LAN-accessible balenaOS device on the fly.\n\nIf `Dockerfile` or any file in the 'build-triggers' list is changed,\na new container will be built and run on your device.\nIf not, changes will simply be synced with `rsync` into the application container.\n\nAfter every 'balena local push' the updated settings will be saved in\n'<source>/.balena-sync.yml' and will be used in later invocations. You can\nalso change any option by editing '.balena-sync.yml' directly.\n\nHere is an example '.balena-sync.yml' :\n\n\t$ cat $PWD/.balena-sync.yml\n\tdestination: '/usr/src/app'\n\tbefore: 'echo Hello'\n\tafter: 'echo Done'\n\tignore:\n\t\t- .git\n\t\t- node_modules/\n\nCommand line options have precedence over the ones saved in '.balena-sync.yml'.\n\nIf '.gitignore' is found in the source directory then all explicitly listed files will be\nexcluded when using rsync to update the container. You can choose to change this default behavior with the\n'--skip-gitignore' option.\n\nExamples:\n\n\t$ balena local push\n\t$ balena local push --app-name test-server --build-triggers package.json,requirements.txt\n\t$ balena local push --force-build\n\t$ balena local push --force-build --skip-logs\n\t$ balena local push --ignore lib/\n\t$ balena local push --verbose false\n\t$ balena local push 192.168.2.10 --source . --destination /usr/src/app\n\t$ balena local push 192.168.2.10 -s /home/user/myBalenaProject -d /usr/src/app --before 'echo Hello' --after 'echo Done'\n\nOptions:\n\n    --source, -s <path>                 root of project directory to push                                                                                       \n    --destination, -d <path>            destination path on device container                                                                                    \n    --ignore, -i <paths>                comma delimited paths to ignore when syncing with 'rsync'                                                               \n    --skip-gitignore                    do not parse excluded/included files from .gitignore                                                                    \n    --before, -b <command>              execute a command before pushing                                                                                        \n    --after, -a <command>               execute a command after pushing                                                                                         \n    --progress, -p                      show progress                                                                                                           \n    --skip-logs                         do not stream logs after push                                                                                           \n    --verbose, -v                       increase verbosity                                                                                                      \n    --app-name, -n <name>               application name - may contain lowercase characters, digits and one or more dashes. It may not start or end with a dash.\n    --build-triggers, -r <files>        comma delimited file list that will trigger a container rebuild if changed                                              \n    --force-build, -f                   force a container build and run                                                                                         \n    --env, -e <env>                     environment variable (e.g. --env 'ENV=value'). Multiple --env parameters are supported.              \n```\n\n##### SSH\n`balena local ssh` discovers balenaOS devices on the local network and allows you to drop a SSH session into any of the containers running on the device. It also enables to you to\ndrop in to the underlying host OS by doing `balena local ssh --host`, however you can of course always just do `ssh root@balena.local -p22222`.\n\n```\n$ balena help local ssh\nUsage: local ssh [deviceIp]\n\nWarning: 'balena local ssh' requires an openssh-compatible client to be correctly\ninstalled in your shell environment. For more information (including Windows\nsupport) please check the README here: https://github.com/balena-io/balena-cli\n\nUse this command to get a shell into the running application container of\nyour device.\n\nThe '--host' option will get you a shell into the Host OS of the balenaOS device.\nNo option will return a list of containers to enter or you can explicitly select\none by passing its name to the --container option\n\nExamples:\n\n\t$ balena local ssh\n\t$ balena local ssh --host\n\t$ balena local ssh --container chaotic_water\n\t$ balena local ssh --container chaotic_water --port 22222\n\t$ balena local ssh --verbose\n\nOptions:\n\n    --verbose, -v                       increase verbosity                 \n    --host, -s                          get a shell into the host OS       \n    --container, -c <container>         name of container to access        \n    --port, -p <port>                   ssh port number (default: 22222)  \n```\n\n##### Logs\n`balena local logs` allows the fetching of logs from any of the running containers on the device.\n\n``` bash\n$ balena help local logs\nUsage: local logs [deviceIp]\n\n\nExamples:\n\n\t$ balena local logs\n\t$ balena local logs -f\n\t$ balena local logs 192.168.1.10\n\t$ balena local logs 192.168.1.10 -f\n\t$ balena local logs 192.168.1.10 -f --app-name myapp\n\nOptions:\n\n    --follow, -f                        follow log                         \n    --app-name, -a <name>               name of container to get logs from\n```\n","jsonml":[["hr"],["hr"],["header",{"level":1},"Architecture Overview"],["header",{"level":2},"Introduction"],["para","BalenaOS is an operating system optimised for running Docker containers on embedded devices, with an emphasis on reliability over long periods of operation, as well as a productive developer workflow inspired by the lessons learned while building balena."],["para","The core insight behind balenaOS is that Linux Containers offer, for the first time, a practical path to using virtualisation on embedded devices. VMs and hypervisors have lead to huge leaps in productivity and automation for cloud deployments, but their abstraction of hardware as well as their resource overhead and lack of hardware support means that they are out of the question for embedded scenarios. With OS-level virtualisation as implemented for Linux Containers, both those objections are lifted for Linux devices, of which there are many in the Internet of Things."],["para","BalenaOS is an operating system built for easy portability to multiple device types (via the Yocto framework) and optimised for Linux Containers, and Docker in particular. There are many decisions, large and small, we have made to enable that vision, which are present throughout our architecture."],["para","The first version of balenaOS was developed as part of balena, and has run on thousands of embedded devices, deployed in many different contexts for several years. BalenaOS v2 represents the combination of the learnings we extracted over those years, as well as our determination to make balenaOS a first-class open source project, able to run as an independent operating system, for any context where embedded devices and containers intersect."],["para","We look forward to working with the community to grow and mature balenaOS into an operating system with even broader device support, a broader operating envelope, and as always, taking advantage of the most modern developments in security and reliability."],["header",{"level":2},"OS composition"],["para","The OS is composed of multiple yocto layers. The ",["link",{"href":"https://www.yoctoproject.org/"},"Yocto Project"]," build system uses these layers to compile balenaOS for the various ",["link",{"href":"./supportedboards.md"},"supported platforms"],".\nThis document will not go into detailed explanation about how the ",["link",{"href":"https://www.yoctoproject.org/"},"Yocto Project"]," works, but will require from the reader a basic understanding of its internals and release versioning/codename."],["para","| Codename | Yocto Project Version | Release Date | Current Version | Support Level | Poky Version | BitBake branch |\n|:--------:|:---------------------:|:------------:|:---------------:|:-------------:|:------------:|:--------------:|\n|   Pyro   |          2.3          |   Apr 2017   |                 |  Development  |              |                |\n|   Morty  |          2.2          |   Oct 2016   |      2.2.1      |     Stable    |     16.0     |      1.32      |\n|  Krogoth |          2.1          |   Apr 2016   |      2.1.2      |     Stable    |     15.0     |      1.30      |\n|  Jethro  |          2.0          |   Nov 2015   |      2.0.3      |   Community   |     14.0     |      1.28      |\n|   Fido   |          1.8          |   Apr 2015   |      1.8.2      |   Community   |     13.0     |      1.26      |\n|   Dizzy  |          1.7          |   Oct 2014   |      1.7.3      |   Community   |     12.0     |      1.24      |\n|   Daisy  |          1.6          |   Apr 2014   |      1.6.3      |   Community   |     11.0     |      1.22      |\n|   Dora   |          1.5          |   Oct 2013   |      1.5.4      |   Community   |     10.0     |      1.20      |"],["para","We will start looking into balenaOS’s composition from the core of the ",["link",{"href":"https://www.yoctoproject.org/"},"Yocto Project"],", i.e. poky. Poky has released a whole bunch of versions and supporting all of them is not in the scope of our OS, but we do try to support its latest versions. This might sound ironic as we do not currently support poky’s last version (i.e. 2.1/Krogoth), but this is only because we did not need this version yet. We tend to support versions of poky based on what our supported boards require and also do a yearly update to the latest poky version for all the boards that can run that version. Currently we support three poky versions: 2.0/Jethro, 1.8/Fido and 1.6/Daisy."],["para","On top of poky we add the collection of packages from meta-openembedded.\nNow that we are done with setting up the build system let’s add Board Support Packages (BSP), these layers are here to provide board-specific configuration and packages (e.g. bootloader, kernel), thus enabling building physical hardware (not emulators). These types of layers are the ones one should be looking for if one wants to add support for a board; if you already have this layer your job should be fairly straightforward, if you do not have it you might be looking into a very cumbersome job.\nAt this point we have all the bits and pieces in place to build an OS.\nThe core code of balenaOS resides in meta-balena. This layer handles a lot of functionality but the main thing that one should remember now is that here one will find the ",["inlinecode","balena-image.bb"]," recipe. This layer also needs a poky version-specific layer to combine with (e.g. meta-balena-jethro), these two layers will give you the necessary framework for the abstract balenaOS generation.\nNow for the final piece of the puzzle, the board-specific meta-balena configuration layer. This layer goes hand in hand with a BSP layer, for example for the Raspberry Pi family (i.e. rpi0, rpi1, rpi2, rpi3) that is supported by the meta-raspberrypi BSP, we provide a meta-balena-raspberrypi layer that configures meta-balena to the raspberrypi's needs."],["para","Below is a representative example from the Raspberry Pi family, which helps explain ",["link",{"href":"https://github.com/balena-os/balena-raspberrypi/blob/master/layers/meta-balena-raspberrypi/conf/samples/bblayers.conf.sample"},"meta-balena-raspberrypi/conf/samples/bblayers.conf.sample"],"."],["para","| Layer Name                        | Repository                                                                      | Description                                                                           |\n|-----------------------------------|-------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|\n| meta-balena                        | https://github.com/balena-os/meta-balena                                        | This repository enables building balenaOS for various devices                         |\n| meta-balena-jethro                 | https://github.com/balena-os/meta-balena                                        | This layer enables building balenaOS for jethro supported BSPs                        |\n| meta-balena-raspberrypi            | https://github.com/balena-os/balena-raspberrypi                                 | Enables building balenaOS for chosen meta-raspberrypi machines.                        |\n| meta-raspberrypi                  | https://github.com/agherzan/meta-raspberrypi                                  | This is the general hardware specific BSP overlay for the Raspberry Pi device family. |\n| meta-openembedded                 | http://git.openembedded.org/meta-openembedded                                 | Collection of OpenEmbedded layers                                                     |\n| meta-openembedded/meta-oe         | https://github.com/openembedded/meta-openembedded/tree/master/meta-oe         |                                                                                       |\n| meta-openembedded/meta-python     | https://github.com/openembedded/meta-openembedded/tree/master/meta-python     | The home of python modules for OpenEmbedded.                                          |\n| meta-openembedded/meta-networking | https://github.com/openembedded/meta-openembedded/tree/master/meta-networking | Central point for networking-relatedpackages and configuration.                       |\n| oe-meta-go                        | https://github.com/mem/oe-meta-go                                             | OpenEmbedded layer for the Go programming language                                    |\n| poky/meta-yocto                   | https://git.yoctoproject.org/git/meta-yocto                                   |                                                                                       |\n| poky/meta                         | https://git.yoctoproject.org/git/poky                                         | Core functionality and configuration of Yocto Project                                 |"],["header",{"level":2},"Userspace Components"],["para","The balenaOS userspace tries to package only the bare essentials for running containers while still offering a lot of flexibility. The philosophy is that software and services always default to being in a container, unless they are generically useful to all containers or they absolutely can’t live in a container.  The userspace consists of many open source components, but in this section we will just highlight some of the important ones."],["para","<img src=\"/images/docs/arch/userspace-components.png\" width=\"90%\">"],["header",{"level":3},"Systemd"],["para","We use systemd as the init system for balenaOS and it is responsible for launching and managing all the other services. We leverage many of the great features of systemd, such as adjusting OOM scores for critical services and running services in separate mount namespaces. Systemd also allows us to easily manage service dependencies."],["header",{"level":3},"Docker"],["para","The Docker engine is a lightweight container runtime that allows us to build and run linux containers on balenaOS. BalenaOS has been optimized to run Docker containers and has been set up to use the journald log driver and DNSmasq for container DNS resolution.\nWe use AUFS as the underlying storage driver since it is arguably the most production tested storage driver in the Docker ecosystem. It also allows us to more easily support devices with older kernel versions and additionally gives us the ability to run on devices with Unmanaged NAND flash."],["header",{"level":3},"NetworkManager and ModemManager"],["para","BalenaOS uses NetworkManager accompanied by ModemManager, to deliver a stable and reliable connection to the internet, be it via ethenet, wifi or cellular modem. Additionally to make headless configuration of the device’s network easy, we have added a ",["inlinecode","system-connections"]," folder in the boot partition which is copied into ",["inlinecode","/etc/NetworkManager/system-connections"],". So any valid NetworkManager connection file can just be dropped into the boot partition before device commissioning."],["header",{"level":3},"DNSmasq"],["para","DNSmasq is here to manage the nameservers that NetworkManager provides for balenaOS.\nNetworkManager will discover the nameservers that can be used and a binary called ",["inlinecode","resolvconf"]," will write them to a tmpfs location, from where DNSmasq will take over and manage these nameservers to give the user the fastest most responsive DNS resolution."],["header",{"level":3},"Avahi"],["para","In order to improve the development experience of balenaOS, there is an Avahi daemon that starts advertising the device as ",["inlinecode","balena.local"]," or ",["inlinecode","<hostname>.local"]," on boot if the image is a development image."],["header",{"level":3},"OpenVPN"],["para","BalenaOS will provide the user with an OpenVPN server that they might use. It is worth noting that this server will be disabled by default and manual interaction from the user is needed to activate and configure this server to their needs."],["header",{"level":2},"Image Partition Layout"],["para","<img src=\"/images/docs/arch/partition-layout.png\" width=\"90%\">"],["para","The first partition, resin-boot, is meant to hold boot important bits according to each board (e.g. kernel image, bootloader image). It also holds a very important file that you will find mentioned elsewhere in this document (i.e. ",["inlinecode","config.json"],"). The config.json file is the central point of configuring balenaOS and defining its behaviour, for example you can set your hostname, allow persistent logging, etc.\nResin-rootA is the partition that holds our read-only root filesystem; it holds almost everything that balenaOS is.\nResin-rootB is an empty partition that is only used when the rootfs is to be updated. We follow the Blue-Green deployment strategy. Essentially we have one active partition that is the OS’s current rootfs and one dormant one that is empty, we download the new rootfs to the dormant partition and try to switch them, if the switch is successful the dormant partition becomes the new rootfs, if not, we rollback to the old active partition.\nResin-state is the partition that holds persistent data as explained in the ",["link",{"href":"#stateless-and-read-only-rootfs"},"Stateless and Read-only rootfs"],".\nResin-data is the partition that holds downloaded Docker images. Generally any container data will be found here."],["header",{"level":2},"Stateless and Read-Only rootFS"],["para","BalenaOS comes with a read-only root filesystem, so we can ensure our hostOS is stateless, but we still need some data to be persistent over system reboots. We achieve this with a very simple mechanism, i.e. bind mounts.\nBalenaOS contains a partition named resin-state that is meant to hold all this persistent data, inside we populate a Linux filesystem hierarchy standard with the rootfs paths that we require to be persistent. After this partition is populated we are ready to bind mount the respective rootfs paths to this read-write location, thus allowing different components (e.g. journald) to be able to write data to disk. A mechanism to purge this partition is provided, thus allowing users to rollback to an unconfigured balenaOS image."],["para","A diagram of our read-only rootfs can be seen below:"],["para","<img src=\"/images/docs/arch/read-only-rootfs.png\" width=\"90%\">"],["header",{"level":2},"Dev vs. Prod images"],["para","BalenaOS comes in two flavours, namely Development (dev) and Production (prod).\nThe Development images are recommended while getting started with balenaOS and building a system.\nThe dev images enable a number of useful features while developing, namely:"],["bulletlist",["listitem","Passwordless SSH to balenaOS"],["listitem","The device broadcasts as balena.local or \\<hostname\\>.local on the network for easy access."],["listitem","Docker socket exposed on via port 2377"],["listitem","Getty console attached to tty1 and serial"]],["para",["strong","Note:"]," Raspberry Pi devices don’t have Getty attached to serial."],["para","The production images have all of the above functionality disabled by default. In both forms of the OS we write logs to an 8 MB journald RAM\nbuffer in order to avoid wear on the flash storage used by most of the supported boards. However, persistent logging can be enabled by setting\nthe ",["inlinecode","\"persistentLogging\": true"]," key in the ",["inlinecode","config.json"]," file in the boot partition of the device."],["header",{"level":2},"OS Tools"],["header",{"level":3},"Base Images"],["para","To help getting started with containers on embedded systems, balenaOS comes with a full complement of over 500 Docker base images. We currently have base images for\nDebian, Fedora and Alpine Linux distributions, as well as Nodejs, Python, Go and Java language base images. For a more in-depth look into all the available base images head over\nto the ",["link",{"href":"http://balena.io/docs/runtime/balena-base-images/"},"balena base images wiki"]," or the ",["link",{"href":"https://hub.docker.com/u/resin/"},"Docker Hub repository"],"."],["header",{"level":3},"Balena Command Line Tool"],["para","The balena CLI is a set of useful tools that help with setting up and developing containers with a balenaOS device. The goal of the CLI is to provide\na simple and intuitive developer experience. Currently, local mode part of the CLI are evolving fast and is considered 'beta', so as always, we love it when you report bugs,\nyou can report them here: ",["link",{"href":"https://github.com/balena-io/balena-cli"},"github.com/balena-io/balena-cli"]],["header",{"level":4},"Installation"],["para","Currently the CLI is a node.js based command line tool which requires that our system has the following dependencies installed and in our path:"],["bulletlist",["listitem",["link",{"href":"https://nodejs.org/en/"},"node.js 6.x"]],["listitem",["link",{"href":"https://www.npmjs.com/"},"npm package manager"]],["listitem",["link",{"href":"https://download.samba.org/pub/rsync/rsync.html"},"rsync"]],["listitem",["link",{"href":"http://www.openssh.com/"},"ssh"]]],["para","Once we have those setup we can install the CLI using npm:\n",["inlinecode"," bash\n$ npm install --global --production --unsafe-perm balena-cli\n"]],["header",{"level":4},"Usage"],["header",{"level":5},"Configure"],["para",["inlinecode","balena local configure"]," allows you configure or reconfigure a balenaOS system image or SD card. Currently, this allows for configuration of wifi settings, hostname and enablement of\npersistent journald logs."],["para",["inlinecode",""],"` bash\n$ balena help local configure\nUsage: local configure <target>"],["para","Use this command to configure or reconfigure a balenaOS drive or image."],["para","Examples:"],["code_block","$ balena local configure /dev/sdc\n$ balena local configure path/to/image.img"],["para",["inlinecode",""],"`"],["header",{"level":5},"Flash"],["para",["inlinecode","balena local flash"]," command helps to easily and safely flash the balenaOS system image on an SD card or USB drive."],["para",["strong","Note:"]," Currently, ",["inlinecode","balena local flash"]," doesn't work with the Intel Edison board."],["para",["inlinecode",""],"` bash\n$ balena help local flash\nUsage: local flash <image>"],["para","Use this command to flash a balenaOS image to a drive."],["para","Examples:"],["code_block","$ balena local flash path/to/balenaos.img\n$ balena local flash path/to/balenaos.img --drive /dev/disk2\n$ balena local flash path/to/balenaos.img --drive /dev/disk2 --yes"],["para","Options:"],["code_block","--yes, -y                           confirm non-interactively          \n--drive, -d <drive>                 drive     "],["para",["inlinecode",""],"`"],["header",{"level":5},"Push"],["para","The ",["inlinecode","balena local push"]," command enables you to quickly build and deploy a Docker container to a target device. It also allows you to easily sync code between your laptop\ndirectory and your running container on the target. Once you have a balenaOS host device running and advertising on the network,\n",["inlinecode","balena local push"]," will allow you to iterate code on a container service. ",["inlinecode","push"]," has a lot of advanced functionality, which all gets encoded into the ",["inlinecode",".balena-sync.yml"]," file in your\nproject directory. To better understand the ",["inlinecode",".yml"]," file, let's look at an example:"],["para",["inlinecode","\n  app-name: myapp\n  build-triggers:\n    - Dockerfile: 9396730559c4107a0d82f95373c45d8e0634556342fb4ee276a7bc1c84c51570\n    - package.json: 1e40740d7cf5018cf887124ee75917eb139d49473c51464580feda247b3a4641\ndestination: /usr/src/app\nignore:\n  - .git\n  - node_modules/\n"]],["para","Let's look a bit into some of these settings keys."],["bulletlist",["listitem",["inlinecode","app-name:"]," represents the name of the Docker image and corresponding running container on the target device."],["listitem",["inlinecode","build-triggers:"]," is a list of file names and their content hashes. Any changes in the files contained in this list will result in a ",["inlinecode","docker build ."]," on the\ntarget device."],["listitem",["inlinecode","destination:"]," this sets the destination sync directory in the container running on the device. This allows you to synchronise a ",["inlinecode","--source"]," directory on your laptop to a running\ncontainer on the device. This is very useful when developing with interpreted languages like Python or Node.js, as you can sync just your source code across, without rebuilding the\nentire container."],["listitem",["inlinecode","ignore:"]," is a list of files or directories that you would like to be ignored during the directory sync. This is useful in the case where you have ",["inlinecode","node_modules"]," in your source\ndirectory that is compiled to run on your x86 laptop, but you are pushing your code over to an ARM based embedded device."]],["para","The push has quite a bit of functionality and a few useful flags. Check out the ",["inlinecode","balena help local push"],":"],["para",["inlinecode",""],"` bash\n$ balena help local push\nUsage: local push ",["link_ref",{"ref":"deviceip","original":"[deviceIp]"},"deviceIp"]],["para","Warning: 'balena local push' requires an openssh-compatible client and 'rsync' to\nbe correctly installed in your shell environment. For more information (including\nWindows support) please check the README here: https://github.com/balena-io/balena-cli"],["para","Use this command to push your local changes to a container on a LAN-accessible balenaOS device on the fly."],["para","If ",["inlinecode","Dockerfile"]," or any file in the 'build-triggers' list is changed,\na new container will be built and run on your device.\nIf not, changes will simply be synced with ",["inlinecode","rsync"]," into the application container."],["para","After every 'balena local push' the updated settings will be saved in\n'<source>/.balena-sync.yml' and will be used in later invocations. You can\nalso change any option by editing '.balena-sync.yml' directly."],["para","Here is an example '.balena-sync.yml' :"],["code_block","$ cat $PWD/.balena-sync.yml\ndestination: '/usr/src/app'\nbefore: 'echo Hello'\nafter: 'echo Done'\nignore:\n\t- .git\n\t- node_modules/"],["para","Command line options have precedence over the ones saved in '.balena-sync.yml'."],["para","If '.gitignore' is found in the source directory then all explicitly listed files will be\nexcluded when using rsync to update the container. You can choose to change this default behavior with the\n'--skip-gitignore' option."],["para","Examples:"],["code_block","$ balena local push\n$ balena local push --app-name test-server --build-triggers package.json,requirements.txt\n$ balena local push --force-build\n$ balena local push --force-build --skip-logs\n$ balena local push --ignore lib/\n$ balena local push --verbose false\n$ balena local push 192.168.2.10 --source . --destination /usr/src/app\n$ balena local push 192.168.2.10 -s /home/user/myBalenaProject -d /usr/src/app --before 'echo Hello' --after 'echo Done'"],["para","Options:"],["code_block","--source, -s <path>                 root of project directory to push                                                                                       \n--destination, -d <path>            destination path on device container                                                                                    \n--ignore, -i <paths>                comma delimited paths to ignore when syncing with 'rsync'                                                               \n--skip-gitignore                    do not parse excluded/included files from .gitignore                                                                    \n--before, -b <command>              execute a command before pushing                                                                                        \n--after, -a <command>               execute a command after pushing                                                                                         \n--progress, -p                      show progress                                                                                                           \n--skip-logs                         do not stream logs after push                                                                                           \n--verbose, -v                       increase verbosity                                                                                                      \n--app-name, -n <name>               application name - may contain lowercase characters, digits and one or more dashes. It may not start or end with a dash.\n--build-triggers, -r <files>        comma delimited file list that will trigger a container rebuild if changed                                              \n--force-build, -f                   force a container build and run                                                                                         \n--env, -e <env>                     environment variable (e.g. --env 'ENV=value'). Multiple --env parameters are supported.              "],["para",["inlinecode",""],"`"],["header",{"level":5},"SSH"],["para",["inlinecode","balena local ssh"]," discovers balenaOS devices on the local network and allows you to drop a SSH session into any of the containers running on the device. It also enables to you to\ndrop in to the underlying host OS by doing ",["inlinecode","balena local ssh --host"],", however you can of course always just do ",["inlinecode","ssh root@balena.local -p22222"],"."],["para",["inlinecode",""],"`\n$ balena help local ssh\nUsage: local ssh ",["link_ref",{"ref":"deviceip","original":"[deviceIp]"},"deviceIp"]],["para","Warning: 'balena local ssh' requires an openssh-compatible client to be correctly\ninstalled in your shell environment. For more information (including Windows\nsupport) please check the README here: https://github.com/balena-io/balena-cli"],["para","Use this command to get a shell into the running application container of\nyour device."],["para","The '--host' option will get you a shell into the Host OS of the balenaOS device.\nNo option will return a list of containers to enter or you can explicitly select\none by passing its name to the --container option"],["para","Examples:"],["code_block","$ balena local ssh\n$ balena local ssh --host\n$ balena local ssh --container chaotic_water\n$ balena local ssh --container chaotic_water --port 22222\n$ balena local ssh --verbose"],["para","Options:"],["code_block","--verbose, -v                       increase verbosity                 \n--host, -s                          get a shell into the host OS       \n--container, -c <container>         name of container to access        \n--port, -p <port>                   ssh port number (default: 22222)  "],["para",["inlinecode",""],"`"],["header",{"level":5},"Logs"],["para",["inlinecode","balena local logs"]," allows the fetching of logs from any of the running containers on the device."],["para",["inlinecode",""],"` bash\n$ balena help local logs\nUsage: local logs ",["link_ref",{"ref":"deviceip","original":"[deviceIp]"},"deviceIp"]],["para","Examples:"],["code_block","$ balena local logs\n$ balena local logs -f\n$ balena local logs 192.168.1.10\n$ balena local logs 192.168.1.10 -f\n$ balena local logs 192.168.1.10 -f --app-name myapp"],["para","Options:"],["code_block","--follow, -f                        follow log                         \n--app-name, -a <name>               name of container to get logs from"],["para",["inlinecode",""],"`"]]}},{"filename":"docs/contrib.md","mime":"text/markdown","title":"Contribute to balenaOS","data":{"markdown":"---\nlayout: docs.html\n---\n\n# Contribute to balenaOS\nThere are many ways to contribute to balenaOS, based on your skills and interests. Whether you are an embedded linux expert or a casual user, you can find areas where you can make a big difference!\n\n## Testing and Bug Reports\nNobody likes buggy software! If you encounter any problems while using balenaOS, you can submit an [issue on github](https://github.com/balena-os/meta-balena/issues). Please include as much information about the problem as possible.\n\nThe same applies for the [balenaOS board support](https://github.com/balena-os?utf8=%E2%9C%93&query=balena-) repositories as well, if you are reporting issues specific to particular hardware.\n\n## Submitting Fixes\nIf you check out the [issues](https://github.com/balena-os/meta-balena/issues) reported for balenaOS, and you find any that you feel you’d like to fix, you can submit a [Pull Request](https://help.github.com/articles/about-pull-requests/) with your proposed change. Please observe the [Contribution Guidelines](https://github.com/balena-os/meta-balena/blob/master/CONTRIBUTING.md).\n\nThe same applies for the [balenaOS board support](https://github.com/balena-os?utf8=%E2%9C%93&query=balena-) repositories as well, if you are fixing issues specific to particular hardware.\n\n## Support for Additional Boards\nBalenaOS is intended to work with any kind of board that fulfills some basic hardware requirements (see our Supported Boards list for currently supported devices). If you have any other board that you’d like to see on that list, please check our [board support contribution guide](https://github.com/balena-os/meta-balena/blob/master/contributing-device-support.md) for more details. You’ll need to be familiar with [Yocto](http://www.yoctoproject.org/), and the board you are adding.\n\n## Documentation\nBalenaOS is quickly evolving, and having good documentation that keeps up with the changes is crucial. If you find any information that is incomplete or missing, you can submit improvements to our documentation on Github!\n\n## Tutorials\nTutorials, how-to guides, and blog posts regarding using balenaOS are always welcome. This would help us figure out how to make balenaOS more usable for everyone, and also help new users to get started. If you have any tutorials and guides, please let us know in the [balena forums](https://balena.io/forums).\n","jsonml":[["hr"],["hr"],["header",{"level":1},"Contribute to balenaOS"],["para","There are many ways to contribute to balenaOS, based on your skills and interests. Whether you are an embedded linux expert or a casual user, you can find areas where you can make a big difference!"],["header",{"level":2},"Testing and Bug Reports"],["para","Nobody likes buggy software! If you encounter any problems while using balenaOS, you can submit an ",["link",{"href":"https://github.com/balena-os/meta-balena/issues"},"issue on github"],". Please include as much information about the problem as possible."],["para","The same applies for the ",["link",{"href":"https://github.com/balena-os?utf8=%E2%9C%93&query=balena-"},"balenaOS board support"]," repositories as well, if you are reporting issues specific to particular hardware."],["header",{"level":2},"Submitting Fixes"],["para","If you check out the ",["link",{"href":"https://github.com/balena-os/meta-balena/issues"},"issues"]," reported for balenaOS, and you find any that you feel you’d like to fix, you can submit a ",["link",{"href":"https://help.github.com/articles/about-pull-requests/"},"Pull Request"]," with your proposed change. Please observe the ",["link",{"href":"https://github.com/balena-os/meta-balena/blob/master/CONTRIBUTING.md"},"Contribution Guidelines"],"."],["para","The same applies for the ",["link",{"href":"https://github.com/balena-os?utf8=%E2%9C%93&query=balena-"},"balenaOS board support"]," repositories as well, if you are fixing issues specific to particular hardware."],["header",{"level":2},"Support for Additional Boards"],["para","BalenaOS is intended to work with any kind of board that fulfills some basic hardware requirements (see our Supported Boards list for currently supported devices). If you have any other board that you’d like to see on that list, please check our ",["link",{"href":"https://github.com/balena-os/meta-balena/blob/master/contributing-device-support.md"},"board support contribution guide"]," for more details. You’ll need to be familiar with ",["link",{"href":"http://www.yoctoproject.org/"},"Yocto"],", and the board you are adding."],["header",{"level":2},"Documentation"],["para","BalenaOS is quickly evolving, and having good documentation that keeps up with the changes is crucial. If you find any information that is incomplete or missing, you can submit improvements to our documentation on Github!"],["header",{"level":2},"Tutorials"],["para","Tutorials, how-to guides, and blog posts regarding using balenaOS are always welcome. This would help us figure out how to make balenaOS more usable for everyone, and also help new users to get started. If you have any tutorials and guides, please let us know in the ",["link",{"href":"https://balena.io/forums"},"balena forums"],"."]]}},{"filename":"docs/custombuild.md","mime":"text/markdown","title":"Building your Own","data":{"markdown":"---\ntitle: Architecture\nlayout: docs.html\n---\n\n# Building your Own\n\n## Bake your own Image\nIn order to build your very own version of balenaOS for one of our supported boards, you will first need to make sure you have a working [Yocto environment setup](http://www.yoctoproject.org/docs/current/yocto-project-qs/yocto-project-qs.html).\nThen pick the device type you want to build, in this example we will use the Raspberry Pi 3. So first we need to grab the [`balena-raspberrypi`](https://github.com/balena-os/balena-raspberrypi) and initialise all its submodules.\n``` bash\ngit clone https://github.com/balena-os/balena-raspberrypi\ngit submodule update --init --recursive\n```\nWe can then use the helpful `BARYS` tool to setup up and start our build. To see all the functionality `BARYS` provides run `./balena-yocto-scripts/build/barys -h`\nfrom with in the repo.\n\nNow to actually build a development version of balenaOS for the Raspberry Pi 3, we can run the following:\n``` bash\n./balena-yocto-scripts/build/barys -m raspberrypi3\n```\n\n**NOTE:** To create a managed build (one that communicates with and can be managed through balena services),\nyou'll need to specify the `--balenaio` flag, as balenaOS builds are unmanaged by default.\n\nNow sit tight and maybe go and make several cups of tea, this is going to take a little while.\n\n## Supporting your Own Board\n\nPre-requisites: a [Yocto](https://www.yoctoproject.org) Board Support Package (BSP) layer for your particular board. It should be compatible to the Yocto releases balenaOS supports.\n\nRepositories used to build balenaOS host Operating System (OS) are typically named `balena-<board-family>`. For example, consider [balena-raspberrypi](https://github.com/balena-os/balena-raspberrypi) which is used for building the OS for [Raspberryi Pi](https://raspberrypi.org), or [balena-intel](https://github.com/balena-os/balena-intel) repository which can be used to build a balena image for the Intel NUC boards.\n\nContributing support for a new board consist of creating a a Yocto package that includes:\n\n* general hardware support for the specific board,\n* the balenaOS-specific software features,\n* deployment-specific features (i.e. settings to create SD card images or self-flashing images)\n\nThe following documentation walks you through the steps of creating such a Yocto package. Because of the substantial difference between the hardware of many boards, this document provides general directions, and often it might be helpful to see the examples of already supported boards. The list of the relevant repositories is found the end of this document.\n\n### Board Support Repository Breakout\n\nThe `balena-<board-family>` repositories use [git submodules](https://git-scm.com/docs/git-submodule) for including required Yocto layers from the relevant sub-projects.\n\nThe root directory shall contain 2 directory entries:\n\n* a `layers` directory\n* [balena-yocto-scripts](https://github.com/balena-os/balena-yocto-scripts) git submodule.\n\n_Note: you add submodules by `git submodule add <url> <directory>`, see the git documentation for more details._\n\nThe root directory generally also includes the following files:\n\n* `CHANGELOG.md`\n* `LICENSE`\n* `README.md`\n* `VERSION`\n\nand one or more files named `<yocto-machine-name>.coffee`, one for each of the boards that the repository will add support for (eg. [`raspberry-pi3.coffee`](https://github.com/balena-os/balena-raspberrypi/blob/master/raspberrypi3.coffee) for Raspberry Pi 3 in `balena-raspberrypi`). This file contains information on the Yocto build for the specific board, in [CoffeeScript](http://coffeescript.org/) format. A minimal version of this file, using Raspberry Pi 3 as the example, would be:\n\n``` coffeescript\nmodule.exports =\n  yocto:\n    machine: 'raspberrypi3'\n    image: 'balena-image'\n    fstype: 'balenaos-img'\n    version: 'yocto-jethro'\n    deployArtifact: 'balena-image-raspberrypi3.balenaos-img'\n    compressed: true\n```\n\nThe `layers` directory contains the git submodules of the yocto layers used in the build process. This normally means the following components are present:\n\n- [poky](https://www.yoctoproject.org/tools-resources/projects/poky)  at the version/revision required by the board BSP\n- [meta-openembedded](https://github.com/openembedded/meta-openembedded) at the revision poky uses\n- [meta-balena](https://github.com/balena-os/meta-balena) using the master branch\n- [oe-meta-go](https://github.com/balena-os/oe-meta-go) using the master branch (there were no branches corresponding to the yocto releases at the time this howto was written)\n- Yocto BSP layer for the board (for example, the BSP layer for Raspberry Pi is [meta-raspberrypi](https://github.com/agherzan/meta-raspberrypi))\n- any additional Yocto layers required by the board BSP (check the Yocto BSP layer of the respective board for instructions on how to build the BSP and what are the Yocto dependencies of that particular BSP layer)\n\nIn addition to the above git submodules, the \"layers\" directory also contains a `meta-balena-<board-family>` directory (please note this directory is _not_ a git submodule, but an actual directory in the ). This directory contains the required customization for making a board balena enabled. For example, the [balena-raspberrypi](https://github.com/balena-os/balena-raspberrypi) repository contains the directory `layers/meta-balena-raspberrypi` to supplement the BSP from `layers/meta-raspberrypi` git submodule, with any changes that might be required by balenaOS.\n\nThe layout so far looks as follows:\n\n```\n├── CHANGELOG.md\n├── LICENSE\n├── README.md\n├── VERSION\n├── layers\n│   ├── meta-openembedded\n│   ├── meta-<board-family>\n│   ├── meta-balena\n│   ├── meta-balena-<board-family>\n│   ├── oe-meta-go\n│   └── poky\n├── <board>.coffee\n└── balena-yocto-scripts\n```\n\n### meta-balena-`<board-family>` breakout\n\nThis directory contains:\n\n* `COPYING.Apache-2.0` file with the [Apache Version 2.0 license](http://www.apache.org/licenses/LICENSE-2.0),\n* `README.md` file specifying the supported boards\n\nand a number of directories out of which the mandatory ones are:\n\n- `conf` directory - contains the following files:\n    - `layer.conf`, see the [layer.conf](https://github.com/balena-os/balena-raspberrypi/blob/master/layers/meta-balena-raspberrypi/conf/layer.conf) from `meta-balena-raspberrypi` for an example, and see [Yocto documentation](http://www.yoctoproject.org/docs/2.0/mega-manual/mega-manual.html#bsp-filelayout-layer)\n    - `samples/bblayers.conf.sample` file in which all the required Yocto layers are listed, see this [bblayers.conf.sample](https://github.com/balena-os/balena-raspberrypi/blob/master/layers/meta-balena-raspberrypi/conf/samples/bblayers.conf.sample) from `meta-balena-raspberrypi` for an example, and see the [Yocto documentation](http://www.yoctoproject.org/docs/2.0/mega-manual/mega-manual.html#var-BBLAYERS)\n    - `samples/local.conf.sample` file which defines part of the build configuration (see the meta-balena [README.md](https://github.com/balena-os/meta-balena/blob/master/README.md) for an overview of some of the variables use in the `local.conf.sample` file). An existing file can be used (e.g. [local.conf.sample](https://github.com/balena-os/balena-raspberrypi/blob/master/layers/meta-balena-raspberrypi/conf/samples/local.conf.sample)) but making sure the \"Supported machines\" area lists the appropriate machines this repository is used for. See also the [Yocto documentation](http://www.yoctoproject.org/docs/2.0/mega-manual/mega-manual.html#structure-build-conf-local.conf).\n\n- `recipes-containers/docker-disk` directory, which contains `docker-balena-supervisor-disk.bbappend` that shall define the following variable(s):\n\n    - `SUPERVISOR_REPOSITORY_<yocto-machine-name>`: this variable is used to specify the build of the supervisor. It can be one of (must match the architecture of the board):\n        *  **balena/armv7hf-supervisor** (for armv7 boards),\n        * **balena/i386-supervisor**\n        (for x86 boards),\n        * **balena/amd64-supervisor** (for x86-64 boards),\n        * **balena/rpi-supervisor** (for raspberry pi 1),\n        * **balena/armel-supervisor** (for armv5 boards).\n\n    - `LED_FILE_<yocto-machine-name>`: this variable should point to the [Linux sysfs path of an unused LED](https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-class-led) if available for that particular board. This allows the unused LED to be flashed for quick visual device identification purposes. If no such unused LED exists, this variable shall not be used.\n\n- `recipes-core/images` directory, which contains at least a `balena-image.bbappend` file. Depending on the type of board you are adding support for, you should have your device support either just `balena-image` or both `balena-image-flasher` and `balena-image`. Generally, `balena-image` is for boards that boot directly\nfrom external storage (these boards do not have internal storage to install balena on). `balena-image-flasher` is used when the targeted board has internal storage so this flasher image is burned onto an SD card or USB stick that is used for the initial boot. When booted, this flasher image will automatically install balena on internal storage.\n\n  The `balena-image.bbappend` file shall define the following variables:\n\n    - `IMAGE_FSTYPES_<yocto-machine-name>`: this variable is used to declare the type of the produced image (it can be ext3, ext4, balenaos-img etc. The usual type for a board that can boot from SD card, USB, is \"balenaos-img\").\n\n    - `BALENA_BOOT_PARTITION_FILES_<yocto-machine-name>`: this allows adding files from the build's deploy directory into the vfat formatted resin-boot partition (can be used to add bootloader config files, first stage bootloader, initramfs or anything else needed for the booting process to take place for your particular board). If the board uses different bootloader configuration files when booting from either external media (USB thumb drive, SD card etc.) or from internal media (mSATA, eMMC etc) then you would want make use of this variable to make sure the different bootloader configuration files get copied over and further manipulated as needed (see `INTERNAL_DEVICE_BOOTLOADER_CONFIG_<yocto-machine-name>` and `INTERNAL_DEVICE_BOOTLOADER_CONFIG_PATH_<yocto-machine-name>` below). Please note that you only reference these files here, it is the responsibility of a `.bb` or `.bbappend` to provide and deploy them (for bootloader config files this is done with an append typically in `recipes-bsp/<your board's bootloader>/<your board's bootloader>.bbappend`, see [balena-intel grub bbappend](https://github.com/balena-os/balena-intel/blob/master/layers/meta-balena-genericx86/recipes-bsp/grub/grub_%25.bbappend) for an example)\n\n    It is a space separated list of items with the following format: *FilenameRelativeToDeployDir:FilenameOnTheTarget*. If *FilenameOnTheTarget* is omitted then the *FilenameRelativeToDeployDir* will be used.\n\n    For example to have the Intel NUC `bzImage-intel-corei7-64.bin` copied from deploy directory over to the boot partition, renamed to `vmlinuz`:\n\n    ```sh\n    BALENA_BOOT_PARTITION_FILES_nuc = \"bzImage-intel-corei7-64.bin:vmlinuz\"\n    ```\n\n  The `balena-image-flasher.bbappend` file shall define the following variables:\n\n    - `IMAGE_FSTYPES_<yocto-machine-name>` (see above)\n    - `BALENA_BOOT_PARTITION_FILES_<yocto-machine-name>` (see above). For example, if the board uses different bootloader configuration files for booting from SD/USB and internal storage (see below the use of `INTERNAL_DEVICE_BOOTLOADER_CONFIG` variable), then make sure these files end up in the boot partition (i.e. they should be listed in this `BALENA_BOOT_PARTITION_FILES_<yocto-machine-name>` variable)\n\n- `recipes-kernel/linux directory`: shall contain a `.bbappend` to the kernel recipe used by the respective board. This kernel `.bbappend` must \"inherit kernel-balena\" in order to add the necessary kernel configs for using with balena.\n\n- `recipes-support/balena-init` directory - shall contain a `balena-init-flasher.bbappend` file if you intend to install balena to internal storage and hence use the flasher image. This shall define the following variables:\n\n  - `INTERNAL_DEVICE_KERNEL_<yocto-machine-name>`: this variable is used to identify the internal storage where balena will be written to.\n  - `INTERNAL_DEVICE_BOOTLOADER_CONFIG_<yocto-machine-name>`: this variable is used to specify the filename of the bootloader configuration file used by your board when booting from internal media (must be the same with the *FilenameOnTheTarget* parameter of the bootloader internal config file used in the `BALENA_BOOT_PARTITION_FILES_<yocto-machine-name>` variable from `recipes-core/images/balena-image-flasher.bbappend`)\n\n  - `INTERNAL_DEVICE_BOOTLOADER_CONFIG_PATH_<yocto-machine-name>`: this variable is used to specify the relative path (including filename) to the resin-boot partition where `INTERNAL_DEVICE_BOOTLOADER_CONFIG_<yocto-machine-name>` will be copied to.\n\n    For example, setting\n\n    ```sh\n    INTERNAL_DEVICE_BOOTLOADER_CONFIG_intel-corei7-64 = \"grub.cfg_internal\"\n    ```\n    and\n    ```sh\n    INTERNAL_DEVICE_BOOTLOADER_CONFIG_PATH_intel-corei7-64 = \"/EFI/BOOT/grub.cfg\"\n    ```\n    will result that after flashing the file `grub.cfg`_internal is copied with the name `grub.cfg` to the /EFI/BOOT/ directory on the resin-boot partition.\n\n\nThe directory structure then looks similar to this:\n```\n├── COPYING.Apache-2.0\n├── README.md\n├── conf\n│   ├── layer.conf\n│   └── samples\n│       ├── bblayers.conf.sample\n│       └── local.conf.sample\n├── recipes-bsp\n│   └── bootfiles\n├── recipes-containers\n│   └── docker-disk\n│       └── docker-balena-supervisor-disk.bbappend\n├── recipes-core\n│   ├── images\n│   │   └── balena-image.bbappend\n├── recipes-kernel\n│   └── linux\n│       ├── linux-<board-family>-<version>\n│       │   └── <patch files>\n│       ├── linux-<board-family>_%.bbappend\n│       └── linux-<board>_<version>.bbappend\n└── recipes-support\n    └── balena-init\n        ├── files\n        │   └── balena-init-board\n        └── balena-init-board.bbappend\n```\n\n### Building\n\nSee the [meta-balena Readme](https://github.com/balena-os/meta-balena/blob/master/README.md) on how to build the new balenaOS image after setting up the new board package as defined above.\n\n### Troubleshooting\n\nFor specific examples on how board support is provided for existing devices, see the repositories in the [Supported Boards](/docs/supportedboards) section.\n","jsonml":[["hr"],["hr"],["header",{"level":1},"Building your Own"],["header",{"level":2},"Bake your own Image"],["para","In order to build your very own version of balenaOS for one of our supported boards, you will first need to make sure you have a working ",["link",{"href":"http://www.yoctoproject.org/docs/current/yocto-project-qs/yocto-project-qs.html"},"Yocto environment setup"],".\nThen pick the device type you want to build, in this example we will use the Raspberry Pi 3. So first we need to grab the ",["link",{"href":"https://github.com/balena-os/balena-raspberrypi"},["inlinecode","balena-raspberrypi"]]," and initialise all its submodules.\n",["inlinecode"," bash\ngit clone https://github.com/balena-os/balena-raspberrypi\ngit submodule update --init --recursive\n"],"\nWe can then use the helpful ",["inlinecode","BARYS"]," tool to setup up and start our build. To see all the functionality ",["inlinecode","BARYS"]," provides run ",["inlinecode","./balena-yocto-scripts/build/barys -h"],"\nfrom with in the repo."],["para","Now to actually build a development version of balenaOS for the Raspberry Pi 3, we can run the following:\n",["inlinecode"," bash\n./balena-yocto-scripts/build/barys -m raspberrypi3\n"]],["para",["strong","NOTE:"]," To create a managed build (one that communicates with and can be managed through balena services),\nyou'll need to specify the ",["inlinecode","--balenaio"]," flag, as balenaOS builds are unmanaged by default."],["para","Now sit tight and maybe go and make several cups of tea, this is going to take a little while."],["header",{"level":2},"Supporting your Own Board"],["para","Pre-requisites: a ",["link",{"href":"https://www.yoctoproject.org"},"Yocto"]," Board Support Package (BSP) layer for your particular board. It should be compatible to the Yocto releases balenaOS supports."],["para","Repositories used to build balenaOS host Operating System (OS) are typically named ",["inlinecode","balena-<board-family>"],". For example, consider ",["link",{"href":"https://github.com/balena-os/balena-raspberrypi"},"balena-raspberrypi"]," which is used for building the OS for ",["link",{"href":"https://raspberrypi.org"},"Raspberryi Pi"],", or ",["link",{"href":"https://github.com/balena-os/balena-intel"},"balena-intel"]," repository which can be used to build a balena image for the Intel NUC boards."],["para","Contributing support for a new board consist of creating a a Yocto package that includes:"],["bulletlist",["listitem","general hardware support for the specific board,"],["listitem","the balenaOS-specific software features,"],["listitem","deployment-specific features (i.e. settings to create SD card images or self-flashing images)"]],["para","The following documentation walks you through the steps of creating such a Yocto package. Because of the substantial difference between the hardware of many boards, this document provides general directions, and often it might be helpful to see the examples of already supported boards. The list of the relevant repositories is found the end of this document."],["header",{"level":3},"Board Support Repository Breakout"],["para","The ",["inlinecode","balena-<board-family>"]," repositories use ",["link",{"href":"https://git-scm.com/docs/git-submodule"},"git submodules"]," for including required Yocto layers from the relevant sub-projects."],["para","The root directory shall contain 2 directory entries:"],["bulletlist",["listitem","a ",["inlinecode","layers"]," directory"],["listitem",["link",{"href":"https://github.com/balena-os/balena-yocto-scripts"},"balena-yocto-scripts"]," git submodule."]],["para",["em","Note: you add submodules by ",["inlinecode","git submodule add <url> <directory>"],", see the git documentation for more details."]],["para","The root directory generally also includes the following files:"],["bulletlist",["listitem",["inlinecode","CHANGELOG.md"]],["listitem",["inlinecode","LICENSE"]],["listitem",["inlinecode","README.md"]],["listitem",["inlinecode","VERSION"]]],["para","and one or more files named ",["inlinecode","<yocto-machine-name>.coffee"],", one for each of the boards that the repository will add support for (eg. ",["link",{"href":"https://github.com/balena-os/balena-raspberrypi/blob/master/raspberrypi3.coffee"},["inlinecode","raspberry-pi3.coffee"]]," for Raspberry Pi 3 in ",["inlinecode","balena-raspberrypi"],"). This file contains information on the Yocto build for the specific board, in ",["link",{"href":"http://coffeescript.org/"},"CoffeeScript"]," format. A minimal version of this file, using Raspberry Pi 3 as the example, would be:"],["para",["inlinecode"," coffeescript\nmodule.exports =\n  yocto:\n    machine: 'raspberrypi3'\n    image: 'balena-image'\n    fstype: 'balenaos-img'\n    version: 'yocto-jethro'\n    deployArtifact: 'balena-image-raspberrypi3.balenaos-img'\n    compressed: true\n"]],["para","The ",["inlinecode","layers"]," directory contains the git submodules of the yocto layers used in the build process. This normally means the following components are present:"],["bulletlist",["listitem",["link",{"href":"https://www.yoctoproject.org/tools-resources/projects/poky"},"poky"],"  at the version/revision required by the board BSP"],["listitem",["link",{"href":"https://github.com/openembedded/meta-openembedded"},"meta-openembedded"]," at the revision poky uses"],["listitem",["link",{"href":"https://github.com/balena-os/meta-balena"},"meta-balena"]," using the master branch"],["listitem",["link",{"href":"https://github.com/balena-os/oe-meta-go"},"oe-meta-go"]," using the master branch (there were no branches corresponding to the yocto releases at the time this howto was written)"],["listitem","Yocto BSP layer for the board (for example, the BSP layer for Raspberry Pi is ",["link",{"href":"https://github.com/agherzan/meta-raspberrypi"},"meta-raspberrypi"],")"],["listitem","any additional Yocto layers required by the board BSP (check the Yocto BSP layer of the respective board for instructions on how to build the BSP and what are the Yocto dependencies of that particular BSP layer)"]],["para","In addition to the above git submodules, the \"layers\" directory also contains a ",["inlinecode","meta-balena-<board-family>"]," directory (please note this directory is ",["em","not"]," a git submodule, but an actual directory in the ). This directory contains the required customization for making a board balena enabled. For example, the ",["link",{"href":"https://github.com/balena-os/balena-raspberrypi"},"balena-raspberrypi"]," repository contains the directory ",["inlinecode","layers/meta-balena-raspberrypi"]," to supplement the BSP from ",["inlinecode","layers/meta-raspberrypi"]," git submodule, with any changes that might be required by balenaOS."],["para","The layout so far looks as follows:"],["para",["inlinecode","\n├── CHANGELOG.md\n├── LICENSE\n├── README.md\n├── VERSION\n├── layers\n│   ├── meta-openembedded\n│   ├── meta-<board-family>\n│   ├── meta-balena\n│   ├── meta-balena-<board-family>\n│   ├── oe-meta-go\n│   └── poky\n├── <board>.coffee\n└── balena-yocto-scripts\n"]],["header",{"level":3},"meta-balena-",["inlinecode","<board-family>"]," breakout"],["para","This directory contains:"],["bulletlist",["listitem",["inlinecode","COPYING.Apache-2.0"]," file with the ",["link",{"href":"http://www.apache.org/licenses/LICENSE-2.0"},"Apache Version 2.0 license"],","],["listitem",["inlinecode","README.md"]," file specifying the supported boards"]],["para","and a number of directories out of which the mandatory ones are:"],["bulletlist",["listitem",["para",["inlinecode","conf"]," directory - contains the following files:"],["bulletlist",["listitem",["inlinecode","layer.conf"],", see the ",["link",{"href":"https://github.com/balena-os/balena-raspberrypi/blob/master/layers/meta-balena-raspberrypi/conf/layer.conf"},"layer.conf"]," from ",["inlinecode","meta-balena-raspberrypi"]," for an example, and see ",["link",{"href":"http://www.yoctoproject.org/docs/2.0/mega-manual/mega-manual.html#bsp-filelayout-layer"},"Yocto documentation"]],["listitem",["inlinecode","samples/bblayers.conf.sample"]," file in which all the required Yocto layers are listed, see this ",["link",{"href":"https://github.com/balena-os/balena-raspberrypi/blob/master/layers/meta-balena-raspberrypi/conf/samples/bblayers.conf.sample"},"bblayers.conf.sample"]," from ",["inlinecode","meta-balena-raspberrypi"]," for an example, and see the ",["link",{"href":"http://www.yoctoproject.org/docs/2.0/mega-manual/mega-manual.html#var-BBLAYERS"},"Yocto documentation"]],["listitem",["para",["inlinecode","samples/local.conf.sample"]," file which defines part of the build configuration (see the meta-balena ",["link",{"href":"https://github.com/balena-os/meta-balena/blob/master/README.md"},"README.md"]," for an overview of some of the variables use in the ",["inlinecode","local.conf.sample"]," file). An existing file can be used (e.g. ",["link",{"href":"https://github.com/balena-os/balena-raspberrypi/blob/master/layers/meta-balena-raspberrypi/conf/samples/local.conf.sample"},"local.conf.sample"],") but making sure the \"Supported machines\" area lists the appropriate machines this repository is used for. See also the ",["link",{"href":"http://www.yoctoproject.org/docs/2.0/mega-manual/mega-manual.html#structure-build-conf-local.conf"},"Yocto documentation"],"."]]]],["listitem",["para",["inlinecode","recipes-containers/docker-disk"]," directory, which contains ",["inlinecode","docker-balena-supervisor-disk.bbappend"]," that shall define the following variable(s):"],["bulletlist",["listitem",["para",["inlinecode","SUPERVISOR_REPOSITORY_<yocto-machine-name>"],": this variable is used to specify the build of the supervisor. It can be one of (must match the architecture of the board):"],["bulletlist",["listitem",["strong","balena/armv7hf-supervisor"]," (for armv7 boards),"],["listitem",["strong","balena/i386-supervisor"],"\n(for x86 boards),"],["listitem",["strong","balena/amd64-supervisor"]," (for x86-64 boards),"],["listitem",["strong","balena/rpi-supervisor"]," (for raspberry pi 1),"],["listitem",["para",["strong","balena/armel-supervisor"]," (for armv5 boards)."]]]],["listitem",["para",["inlinecode","LED_FILE_<yocto-machine-name>"],": this variable should point to the ",["link",{"href":"https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-class-led"},"Linux sysfs path of an unused LED"]," if available for that particular board. This allows the unused LED to be flashed for quick visual device identification purposes. If no such unused LED exists, this variable shall not be used."]]]],["listitem",["para",["inlinecode","recipes-core/images"]," directory, which contains at least a ",["inlinecode","balena-image.bbappend"]," file. Depending on the type of board you are adding support for, you should have your device support either just ",["inlinecode","balena-image"]," or both ",["inlinecode","balena-image-flasher"]," and ",["inlinecode","balena-image"],". Generally, ",["inlinecode","balena-image"]," is for boards that boot directly\nfrom external storage (these boards do not have internal storage to install balena on). ",["inlinecode","balena-image-flasher"]," is used when the targeted board has internal storage so this flasher image is burned onto an SD card or USB stick that is used for the initial boot. When booted, this flasher image will automatically install balena on internal storage."],["para","The ",["inlinecode","balena-image.bbappend"]," file shall define the following variables:"],["bulletlist",["listitem",["para",["inlinecode","IMAGE_FSTYPES_<yocto-machine-name>"],": this variable is used to declare the type of the produced image (it can be ext3, ext4, balenaos-img etc. The usual type for a board that can boot from SD card, USB, is \"balenaos-img\")."]],["listitem",["para",["inlinecode","BALENA_BOOT_PARTITION_FILES_<yocto-machine-name>"],": this allows adding files from the build's deploy directory into the vfat formatted resin-boot partition (can be used to add bootloader config files, first stage bootloader, initramfs or anything else needed for the booting process to take place for your particular board). If the board uses different bootloader configuration files when booting from either external media (USB thumb drive, SD card etc.) or from internal media (mSATA, eMMC etc) then you would want make use of this variable to make sure the different bootloader configuration files get copied over and further manipulated as needed (see ",["inlinecode","INTERNAL_DEVICE_BOOTLOADER_CONFIG_<yocto-machine-name>"]," and ",["inlinecode","INTERNAL_DEVICE_BOOTLOADER_CONFIG_PATH_<yocto-machine-name>"]," below). Please note that you only reference these files here, it is the responsibility of a ",["inlinecode",".bb"]," or ",["inlinecode",".bbappend"]," to provide and deploy them (for bootloader config files this is done with an append typically in ",["inlinecode","recipes-bsp/<your board's bootloader>/<your board's bootloader>.bbappend"],", see ",["link",{"href":"https://github.com/balena-os/balena-intel/blob/master/layers/meta-balena-genericx86/recipes-bsp/grub/grub_%25.bbappend"},"balena-intel grub bbappend"]," for an example)"]]],["para","It is a space separated list of items with the following format: ",["em","FilenameRelativeToDeployDir:FilenameOnTheTarget"],". If ",["em","FilenameOnTheTarget"]," is omitted then the ",["em","FilenameRelativeToDeployDir"]," will be used."],["para","For example to have the Intel NUC ",["inlinecode","bzImage-intel-corei7-64.bin"]," copied from deploy directory over to the boot partition, renamed to ",["inlinecode","vmlinuz"],":"],["para",["inlinecode","sh\nBALENA_BOOT_PARTITION_FILES_nuc = \"bzImage-intel-corei7-64.bin:vmlinuz\"\n"]],["para","The ",["inlinecode","balena-image-flasher.bbappend"]," file shall define the following variables:"],["bulletlist",["listitem",["inlinecode","IMAGE_FSTYPES_<yocto-machine-name>"]," (see above)"],["listitem",["inlinecode","BALENA_BOOT_PARTITION_FILES_<yocto-machine-name>"]," (see above). For example, if the board uses different bootloader configuration files for booting from SD/USB and internal storage (see below the use of ",["inlinecode","INTERNAL_DEVICE_BOOTLOADER_CONFIG"]," variable), then make sure these files end up in the boot partition (i.e. they should be listed in this ",["inlinecode","BALENA_BOOT_PARTITION_FILES_<yocto-machine-name>"]," variable)"]]],["listitem",["para",["inlinecode","recipes-kernel/linux directory"],": shall contain a ",["inlinecode",".bbappend"]," to the kernel recipe used by the respective board. This kernel ",["inlinecode",".bbappend"]," must \"inherit kernel-balena\" in order to add the necessary kernel configs for using with balena."]],["listitem",["para",["inlinecode","recipes-support/balena-init"]," directory - shall contain a ",["inlinecode","balena-init-flasher.bbappend"]," file if you intend to install balena to internal storage and hence use the flasher image. This shall define the following variables:"],["bulletlist",["listitem",["para",["inlinecode","INTERNAL_DEVICE_KERNEL_<yocto-machine-name>"],": this variable is used to identify the internal storage where balena will be written to."]],["listitem",["para",["inlinecode","INTERNAL_DEVICE_BOOTLOADER_CONFIG_<yocto-machine-name>"],": this variable is used to specify the filename of the bootloader configuration file used by your board when booting from internal media (must be the same with the ",["em","FilenameOnTheTarget"]," parameter of the bootloader internal config file used in the ",["inlinecode","BALENA_BOOT_PARTITION_FILES_<yocto-machine-name>"]," variable from ",["inlinecode","recipes-core/images/balena-image-flasher.bbappend"],")"]],["listitem",["para",["inlinecode","INTERNAL_DEVICE_BOOTLOADER_CONFIG_PATH_<yocto-machine-name>"],": this variable is used to specify the relative path (including filename) to the resin-boot partition where ",["inlinecode","INTERNAL_DEVICE_BOOTLOADER_CONFIG_<yocto-machine-name>"]," will be copied to."],["para","For example, setting"],["para",["inlinecode","sh\nINTERNAL_DEVICE_BOOTLOADER_CONFIG_intel-corei7-64 = \"grub.cfg_internal\"\n"],"\nand\n",["inlinecode","sh\nINTERNAL_DEVICE_BOOTLOADER_CONFIG_PATH_intel-corei7-64 = \"/EFI/BOOT/grub.cfg\"\n"],"\nwill result that after flashing the file ",["inlinecode","grub.cfg"],"_internal is copied with the name ",["inlinecode","grub.cfg"]," to the /EFI/BOOT/ directory on the resin-boot partition."]]]]],["para","The directory structure then looks similar to this:\n",["inlinecode","\n├── COPYING.Apache-2.0\n├── README.md\n├── conf\n│   ├── layer.conf\n│   └── samples\n│       ├── bblayers.conf.sample\n│       └── local.conf.sample\n├── recipes-bsp\n│   └── bootfiles\n├── recipes-containers\n│   └── docker-disk\n│       └── docker-balena-supervisor-disk.bbappend\n├── recipes-core\n│   ├── images\n│   │   └── balena-image.bbappend\n├── recipes-kernel\n│   └── linux\n│       ├── linux-<board-family>-<version>\n│       │   └── <patch files>\n│       ├── linux-<board-family>_%.bbappend\n│       └── linux-<board>_<version>.bbappend\n└── recipes-support\n    └── balena-init\n        ├── files\n        │   └── balena-init-board\n        └── balena-init-board.bbappend\n"]],["header",{"level":3},"Building"],["para","See the ",["link",{"href":"https://github.com/balena-os/meta-balena/blob/master/README.md"},"meta-balena Readme"]," on how to build the new balenaOS image after setting up the new board package as defined above."],["header",{"level":3},"Troubleshooting"],["para","For specific examples on how board support is provided for existing devices, see the repositories in the ",["link",{"href":"/docs/supportedboards"},"Supported Boards"]," section."]]}},{"filename":"docs/dynamic.md","mime":"text/markdown","title":"Dynamic page about {{ $os.name }} & {{ $language.name }}","data":{"markdown":"---\ndynamic:\n  variables: [ $os, $language ]\n  ref: docs/$os/$language/dynamic\n  $switch_text: Getting Started with $os and $language\n---\n\n# Dynamic page about {{ $os.name }} & {{ $language.name }}\n\nHey, this is the page about **{{ $os.name }}** and **{{ $language.name }}**.\n\n## Smart import\n\n{{ import \"imported\" }}\n\n## Helpers Example\n\n{{#eq $os.id \"osx\"}}\n  **This page _is about_ OSX**.\n  This paragraph is rendered using the Handlebars helper.\n{{else}}\n  **This page _is NOT about_ OSX**.\n  This paragraph is rendered using the Handlebars helper.\n{{/eq}}\n","jsonml":[["hr"],["hr"],["header",{"level":1},"Dynamic page about {{ $os.name }} & {{ $language.name }}"],["para","Hey, this is the page about ",["strong","{{ $os.name }}"]," and ",["strong","{{ $language.name }}"],"."],["header",{"level":2},"Smart import"],["para","{{ import \"imported\" }}"],["header",{"level":2},"Helpers Example"],["para","{{#eq $os.id \"osx\"}}\n  ",["strong","This page ",["em","is about"]," OSX"],".\n  This paragraph is rendered using the Handlebars helper.\n{{else}}\n  ",["strong","This page ",["em","is NOT about"]," OSX"],".\n  This paragraph is rendered using the Handlebars helper.\n{{/eq}}"]]}},{"filename":"docs/faqs.md","mime":"text/markdown","data":{"markdown":"## Why Docker containers on embedded devices?\n\nWe think that containers are essential to bringing modern development and deployment capabilities to connected devices. Linux containers, particularly Docker, offer, for the first time, a practical path to using virtualization on embedded devices. Virtual machines and hypervisors have lead to huge leaps in productivity and automation for cloud deployments, but their abstraction of hardware as well as their resource overhead and lack of hardware support means that they are out of the question for embedded scenarios. With OS-level virtualization as implemented for Linux Containers, both those objections are lifted for heterogeneous embedded Linux devices in the “Internet of Things.”\n\n## Why Yocto?\n\nYocto Linux is an incredible toolkit for generating Linux distributions, with a focus on portability. Yocto’s minimal size and low footprint also make it ideal for running on devices. BalenaOS is built using Yocto at its core, and the balenaOS team maintains numerous BSPs for Yocto, among them the Raspberry Pi, Artik, and CHIP layers. Yocto acts as the foundation for many other embedded operating systems including Ostro, Wind River Linux, and Tizen, therefore acting as a mechanism for sharing best practices and code, benefitting all the resulting operating systems, balenaOS included.\n\nDevelopers some times avoid Yocto due to its extremely minimal userspace and lack of a standard package manager. BalenaOS uses containers to run arbitrary base images within which developers can work, so that their interaction with the host userspace is rare. In this way we get the considerable portability benefits of Yocto, without suffering the workflow drawbacks for application developers.\n\n## How is this different from cloud operating systems for containers?\n\nBalenaOS shares a lot with cloud operating systems for containers. We share the focus on minimalism, getting out of the user’s way and letting their container do the heavy lifting, and using Docker, which is the standard way of running containers, and well understood by a large developer community. BalenaOS applies the same principles to a different domain, that of embedded Linux devices, sometimes called “connected devices”, “Internet of Things” or “Industrial Internet”, depending on the use case. While some of the cloud operating systems have been made to run on particular embedded devices, their architecture is geared towards the cloud, where they shine.\n\nBy applying the container paradigm to the embedded world, the BalenaOS team has faced and solved a unique set of challenges that are not common in the cloud and datacentre world, such as:\n\n* The extreme heterogeneity of device types found in the wild;\n* Severely restricted resource envelopes in terms of storage, CPU, and networking;\n* Devices that are difficult to reach or re-provision upon failure, where power is unstable and may be turned off at any time, or with custom hardware attached.\n\nBalenaOS is built for this world from scratch, and our deepest architectural and feature choices have been made exclusively with embedded devices in mind. BalenaOS is built for embedded devices, and this focus continues to drive our architectural objectives.\n\n## How is this different from other embedded operating systems?\n\nBalenaOS uniquely combines the virtues of mature embedded operating systems with the developer-focused sensibilities of cloud operating systems. Where the cloud operating systems don’t address the realities of the embedded world, embedded and IoT-focused Linux distributions don’t focus on containers. When they do, they often choose to reinvent the wheel rather than use Docker, which is the de-facto standard among developers. BalenaOS aims to be a competent embedded operating system and shares architectural principles with many existing systems, but also aims to unify the approach to containers with Docker.\n\nWhile others have done a fantastic job evangelising the use of containers on embedded devices, balenaOS has the added benefit of focusing on portability, with 20 device types already supported, and production-readiness, with thousands of devices already deployed for business purposes.\n","jsonml":[["header",{"level":2},"Why Docker containers on embedded devices?"],["para","We think that containers are essential to bringing modern development and deployment capabilities to connected devices. Linux containers, particularly Docker, offer, for the first time, a practical path to using virtualization on embedded devices. Virtual machines and hypervisors have lead to huge leaps in productivity and automation for cloud deployments, but their abstraction of hardware as well as their resource overhead and lack of hardware support means that they are out of the question for embedded scenarios. With OS-level virtualization as implemented for Linux Containers, both those objections are lifted for heterogeneous embedded Linux devices in the “Internet of Things.”"],["header",{"level":2},"Why Yocto?"],["para","Yocto Linux is an incredible toolkit for generating Linux distributions, with a focus on portability. Yocto’s minimal size and low footprint also make it ideal for running on devices. BalenaOS is built using Yocto at its core, and the balenaOS team maintains numerous BSPs for Yocto, among them the Raspberry Pi, Artik, and CHIP layers. Yocto acts as the foundation for many other embedded operating systems including Ostro, Wind River Linux, and Tizen, therefore acting as a mechanism for sharing best practices and code, benefitting all the resulting operating systems, balenaOS included."],["para","Developers some times avoid Yocto due to its extremely minimal userspace and lack of a standard package manager. BalenaOS uses containers to run arbitrary base images within which developers can work, so that their interaction with the host userspace is rare. In this way we get the considerable portability benefits of Yocto, without suffering the workflow drawbacks for application developers."],["header",{"level":2},"How is this different from cloud operating systems for containers?"],["para","BalenaOS shares a lot with cloud operating systems for containers. We share the focus on minimalism, getting out of the user’s way and letting their container do the heavy lifting, and using Docker, which is the standard way of running containers, and well understood by a large developer community. BalenaOS applies the same principles to a different domain, that of embedded Linux devices, sometimes called “connected devices”, “Internet of Things” or “Industrial Internet”, depending on the use case. While some of the cloud operating systems have been made to run on particular embedded devices, their architecture is geared towards the cloud, where they shine."],["para","By applying the container paradigm to the embedded world, the BalenaOS team has faced and solved a unique set of challenges that are not common in the cloud and datacentre world, such as:"],["bulletlist",["listitem","The extreme heterogeneity of device types found in the wild;"],["listitem","Severely restricted resource envelopes in terms of storage, CPU, and networking;"],["listitem","Devices that are difficult to reach or re-provision upon failure, where power is unstable and may be turned off at any time, or with custom hardware attached."]],["para","BalenaOS is built for this world from scratch, and our deepest architectural and feature choices have been made exclusively with embedded devices in mind. BalenaOS is built for embedded devices, and this focus continues to drive our architectural objectives."],["header",{"level":2},"How is this different from other embedded operating systems?"],["para","BalenaOS uniquely combines the virtues of mature embedded operating systems with the developer-focused sensibilities of cloud operating systems. Where the cloud operating systems don’t address the realities of the embedded world, embedded and IoT-focused Linux distributions don’t focus on containers. When they do, they often choose to reinvent the wheel rather than use Docker, which is the de-facto standard among developers. BalenaOS aims to be a competent embedded operating system and shares architectural principles with many existing systems, but also aims to unify the approach to containers with Docker."],["para","While others have done a fantastic job evangelising the use of containers on embedded devices, balenaOS has the added benefit of focusing on portability, with 20 device types already supported, and production-readiness, with thousands of devices already deployed for business purposes."]]}},{"filename":"docs/gettingstarted.md","mime":"text/markdown","title":"Getting Started on the {{ $device.name }}","data":{"markdown":"---\ndynamic:\n  variables: [ $device ]\n  ref: docs/$device/gettingstarted\n  $switch_text: Getting Started with $device\n---\n\n# Getting Started on the {{ $device.name }}\n\nIn balenaOS all application logic and services are encapsulated in Docker containers. In this getting started guide we will walk you through setting up one of our pre-built development OS images and creating a simple application container. In the guide we will use the `balena` CLI tool to make things super easy. However, for those that like to do things the hard way, we got you covered as well.\n\n## Download an Image\nTo get a balenaOS device setup, we will first need to flash a system image on to the device, so head over to [balena.io/os](https://balena.io/os) and grab the development OS for your board. Currently balenaOS supports 20 different boards and several different architectures. See the [Supported Boards](/docs/supportedboards/) section for more details.\n\nOnce the download is finished, make sure to decompress it and keep it somewhere safe, we will need it very soon!\n``` bash\n$ wget {{ $device.download_url }}\n```\n\n## Install the Balena CLI\nThe balena cli, is a collection of utilities which helps us to develop balenaOS based application containers. It’s not strictly necessary, but makes life so so much sweeter, but if you like doing things the hard way, skip over to the next section.\n\nCurrently the CLI is a node.js based command line tool which requires that our system has the following dependencies installed and in our path:\n\n\n* [node.js 6.x](https://nodejs.org/en/)\n* [npm package manager](https://www.npmjs.com/)\n* [rsync](https://download.samba.org/pub/rsync/rsync.html)\n* [ssh](http://www.openssh.com/)\n\nOnce we have those setup we can install `balena` CLI using npm:\n``` bash\n$ npm install --global --production --unsafe-perm balena-cli\n```\n\n__Note:__ Depending on you node.js installation, you may need to use administrative privileges to install the CLI.\n\n## Configure the Image\nTo allow balenaOS images to be easily configurable before boot, some key config files are added to boot partition. In this step we will use the CLI to configure the network, set our hostname to `balena` and disable persistent logging, because we don’t want to kill our poor flash storage with excessive writes.\n``` bash\n$ sudo balena local configure ~/Downloads/balena.img\n? Network SSID super_wifi\n? Network Key super secure password\n? Do you want to set advanced settings? Yes\n? Device Hostname balena\n? Do you want to enable persistent logging? no\nDone!\n```\n\nIf you are not using the balena CLI, you will need to mount the boot partition of the image and edit the configuration manually.\n\nEdit `/boot/config.json` so it looks like this:\n``` json\n{\n  \"persistentLogging\": false,\n  \"hostname\": \"balena\",\n}\n```\n\nAnd edit the `ssid` and `psk` values in the `/boot/system-connections/resin-sample` connection file.\n```\n[connection]\nid=balena-sample\ntype=wifi\n\n[wifi]\nmode=infrastructure\nssid=I_Love_Unicorns\n\n[wifi-security]\nauth-alg=open\nkey-mgmt=wpa-psk\npsk=superSecretPassword\n\n[ipv4]\nmethod=auto\n\n[ipv6]\naddr-gen-mode=stable-privacy\nmethod=auto\n```\n\nIf you only want to use an ethernet connection on your device, you don't need to add anything. The device will automatically set up an ethernet connection by default.\n\n## Get the Device Up and Running\nOkay, so now we have a fully configured image ready to go, so let’s burn and boot this baby. For this step the CLI provides a handy flashing utility, you can however flash this image using etcher.io or `dd` if you must.\n\n### Flash {{ $device.bootMedia }}\nTo get flashing, just point the `balena local flash` command to the image we just downloaded and follow the prompts. If you hate prompts, the CLI also allows you to skip them, check the [balena CLI docs](https://balena.io/docs/architecture/#balena-command-line-tool) on how to do this.\n\n__NOTE:__ `balena local flash` requires administrative privileges because it needs to access the {{ $device.bootMedia }}.\n\n``` bash\n$ sudo balena local flash ~/Downloads/balena.img\nPassword:\nx No available drives were detected, plug one in!\n```\n\nOnce you plug in your {{ $device.bootMedia }}, the CLI should detect it and show you the following selection dialog. Make sure to select the correct drive if you have a few listed, as this will completely write over the drive.\n\n``` bash\n$ sudo balena local flash ~/Downloads/balena.img\nPassword:\n? Select drive (Use arrow keys)\n❯ /dev/disk3 (7.9 GB) - STORAGE DEVICE\n```\n\nOnce you are happy you have selected the correct drive, hit enter and wait while your new OS is written to the drive.\nIt should only take about 3 minutes, depending on the quality of your drive, so this is a great time to go grab a caffeinated beverage.\n\n``` bash\n$ sudo balena local flash ~/Downloads/balena.img\n? Select drive /dev/disk3 (7.9 GB) - STORAGE DEVICE\n? This will erase the selected drive. Are you sure? Yes\nFlashing [========================] 100% eta 0s  \nValidating [========================] 100% eta 0s\n```\n\n__Note:__ Remember to safely remove your {{ $device.bootMedia }} before pulling it out.\n\n### Boot the device\n\n{{ import \"bootdevice\" }}\n\nAfter about 30 seconds or so your device should be up and connected to your local network, you should see it broadcasting itself as `balena.local`. To check this, let’s try ping the device.\n\n``` bash\n$ ping balena.local\nPING 192.168.1.111 (192.168.1.111): 56 data bytes\n64 bytes from 192.168.1.111: icmp_seq=0 ttl=64 time=103.674 ms\n64 bytes from 192.168.1.111: icmp_seq=1 ttl=64 time=9.723 ms\n^C\n--- 192.168.1.111 ping statistics ---\n6 packets transmitted, 6 packets received, 0.0% packet loss\nround-trip min/avg/max/stddev = 7.378/24.032/103.674/35.626 ms\n```\n\nNow if we want to poke around a bit inside balenaOS we can just ssh in with:\n``` bash\n$ ssh root@balena.local -p22222\nroot@balena:~# uname -a\nLinux balena 4.1.21 #1 SMP Fri Oct 7 23:37:01 CEST 2016 armv7l GNU/Linux\nroot@balena:~# balena info\nContainers: 1\n Running: 0\n Paused: 0\n Stopped: 1\nImages: 7\nServer Version: 1.10.3\nStorage Driver: aufs\n Root Dir: /var/lib/balena/aufs\n Backing Filesystem: extfs\n Dirs: 22\n Dirperm1 Supported: true\nExecution Driver: native-0.2\nLogging Driver: journald\nPlugins:\n Volume: local\n Network: null host bridge\nKernel Version: 4.1.21\nOperating System: Balena OS 1.16.1\nOSType: linux\nArchitecture: armv7l\nCPUs: 4\nTotal Memory: 972.5 MiB\nName: balena\nID: FOZ2:5KHG:RTSS:UQ7S:F2J6:QYLL:MERX:5ZVU:4WVL:3G2G:T2YA:LX3D\n```\n\n__Note:__ Beginning with version 2.9.0, balenaOS uses the [balena](https://www.balena.io/) container engine to manage Docker containers. If you are using an earlier version of the OS, replace `balena` commands with `docker`.\n\n## Running your first Container\n### Clone a demo Project\n{{#eq $device.id \"nuc\"}}\n``` bash\n$ git clone https://github.com/balena-io-playground/balenaos-sample-x86\n```\n{{else}}\n``` bash\n$ git clone https://github.com/balena-io-playground/balenaos-sample\n```\n{{/eq}}\n\n### Get a Container Running\n``` bash\n$ sudo balena local push balena.local --source .\n```\nThis command will use the image specified by the `Dockerfile` in the root of your project directory (--source specifies where to find your project). The build of this image will happen on your balenaOS device and once completed, the command will start up a container from that newly built image. For more details look at the [Creating a Project from Scratch](#creating-a-project-from-scratch) section below.\n\n## Poking Around balenaOS\nTo help explore balenaOS devices and application containers more easily, the balena CLI has an ssh command which will help you connect either to the HostOS or a running container on the device.\n\n#### To ssh into the host:\n``` bash\n$ sudo balena local ssh --host\n```\n**OR**\n``` bash\n$ ssh root@balena.local -p22222\n```\n\n#### To ssh into a particular container:\n``` bash\n$ sudo balena local ssh balena.local\n```\n**OR**\n``` bash\n$ ssh root@balena.local -p22222\nroot@balena:~# balena exec -it myapp bash\n```\n\n## Going Further\n### Advanced Settings\n\nEither mount the {{ $device.bootMedia }} and run:\n``` bash\n$ sudo balena local configure /path/to/drive\n```\nAnd select `y` when asked if you want to add advanced settings.\n\nAlternatively you can add `“persistentLogging”: true` to `config.json` in your boot partition of the {{ $device.bootMedia }}.\n\nTo Enable persistent logs in a running device, add `“persistentLogging”: true` to `/mnt/boot/config.json` and reboot.\n\nThe journal can be found at  `/var/log/journal/` which is bind mounted to `root-overlay/var/log/journal` in the `resin-state` partition.\nWhen logging is not persistent, the logs can be found at `/run/log/journal/` and this log is volatile so you will loose all logs when you power the device down.\n\n## Creating a Project from Scratch\nAlright! So we have an awesome container machine up and running on our network. So let’s start pushing some application containers onto it. In this section we will do a quick walk through of setting up a `Dockerfile` and make a simple little node.js webserver.\n\nTo get started, let’s create a new project directory called “myapp” and create a new file called `Dockerfile`.\n\n``` bash\n$ mkdir -p myapp && touch Dockerfile\n```\n\nNow we will create a minimal node.js container based on the slim [Alpine Linux distro](link-to-alpine). We do this by adding the following lines to our Dockerfile.\n\n``` Dockerfile\nFROM resin/{{ $device.id }}-alpine-node:slim\nCMD [“cat”, “/etc/os-release”]\n```\n\nThe `FROM` tells Docker what our container will be based on. In this case an Alpine Linux userspace with just the bare essentials needed for the node.js runtime. The `CMD` just defines what our container runs on startup. In this case, it’s not very exciting yet.\n\nNow to get our application running on our device we can use the `balena local push` functionality.\n```bash\n$ sudo balena local push balena.local --source .\n* Building..\n- Stopping and Removing any previous 'myapp' container\n- Removing any existing container images for 'myapp'\n- Building new 'myapp' image\nStep 1 : FROM resin/{{ $device.id }}-alpine-node:slim\nPulling from resin/{{ $device.id }}-alpine-node\nPulling fs layer\nVerifying Checksum=============================================>]     32 B/32 B7 MB\nDownload complete\nVerifying Checksum=============================================>] 1.987 MB/1.987 MB\nPull complete=================================================>]    12 MB/12 MB\nPull complete\nDigest: sha256:410a5add3aa281d97afea1ae4fcdbec203c69ea34faea8d84349456c211f33a3\nStatus: Downloaded newer image for resin/{{ $device.id }}-alpine-node:slim\n ---> bf37b6350e63\nStep 2 : CMD [“cat”, “/etc/os-release”]\n ---> Running in a376f4a781d5\n ---> a3c2c42b1212\nRemoving intermediate container a376f4a781d5\nSuccessfully built a3c2c42b1212\n- Creating 'myapp' container\n- Starting 'myapp' container\n\nbalena push completed successfully!\n```\n\nThis command will discover your balenaOS-dev device on the network and start a build of whatever you have in the `--source` directory. In the example above, we have just told it to build from the root of the directory we are in, in this case `myapp`.\n\nA number of things have happened in this step, so let’s pause here and dig in a little more. When we first run `balena local push` we are asked to define a name for our app and after that, it starts a Docker build on your device. At the same time, the CLI has added a file to our project called `.resin-sync.yml` which stores all the project defaults. Let’s have a quick look at that:\n\n``` yaml\nlocal_balenaos:\n  app-name: myapp\n  build-triggers:\n    - Dockerfile: 6275495dc9620c3c74aa5a25ef29bbb109fbcb4e46de941b14235aeea02cc184\n```\n\nWe can see that for our local balenaOS device we have an app called “myapp” which will map over to a Docker image and container on our device. The next interesting section is build-triggers. This is a list of files and their hashes, which will result in a Docker build. In our case it’s just the `Dockerfile`, so when we change things here, the CLI will rebuild our app. This will be important a bit later.\n\nSo now that we are building, let’s start adding some actual code! We will just add `main.js` file in the root of our `myapp` directory.\n\n``` javascript\n//main.js\nconsole.log(\"Hey… I’m a node.js app running in a container!!\");\n```\n\nWe then make sure our Dockerfile copies this source file into our container context by replacing our current `CMD [“cat”,”/etc/os-release”]` in our Dockerfile with the following.\n\n``` Dockerfile\nFROM resin/{{ $device.id }}-alpine-node:slim\nWORKDIR /usr/src/app\nCOPY . .\nCMD [\"node\", \"main.js\"]\n```\n\nThis puts all the contents of our `myapp` directory into `/usr/src/app` in our running container and says we should start main.js when the container starts.\n\nAlright, so we have a simple javascript container, but that’s pretty boring, let’s add some dependencies and complexity.  To add dependencies in node.js we need a package.json, the easiest way to whip up one is to just run `npm init` in the root of our `myapp` directory. After a nice little interactive dialog we have the following `package.json` in directory.\n\n``` json\n{\n  \"name\": \"myapp\",\n  \"version\": \"1.0.0\",\n  \"description\": \"a simple hello world webserver\",\n  \"main\": \"main.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"no tests yet\\\"\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"none\"\n  },\n  \"author\": \"Shaun Mulligan <shaun@balena.io>\",\n  \"license\": \"ISC\"\n}\n```\n\nNow it’s time to add some dependencies. For our little webserver, we will use the popular expressjs module. We can add it to the `package.json` after the `\"license\": \"ISC\"`, so it now looks like this:\n\n``` json\n{\n  \"name\": \"myapp\",\n  \"version\": \"1.0.0\",\n  \"description\": \"a simple hello world webserver\",\n  \"main\": \"main.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"no tests yet\\\"\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"none\"\n  },\n  \"author\": \"Shaun Mulligan <shaun@balena.io>\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"express\": \"^4.14.0\"\n  }\n}\n```\n\nNow all we need to do is add a few more lines of javacript to our main.js and we are off to the races.\n\n``` javascript\n//main.js\n\nvar express = require('express');\nvar app = express();\n\n// reply to request with \"Hello World!\"\napp.get('/', function (req, res) {\n  res.send(\"Hello World, I'm a container running on balenaOS!\");\n});\n\n//start a server on port 80 and log its start to our console\nvar server = app.listen(80, function () {\n\n  var port = server.address().port;\n  console.log(\"Hey… I’m a node.js server running in a container and listening on port: \", port);\n});\n```\n\nGreat, so now we are almost ready to go, but we want to make sure anytime we add a dependency to our `package.json` that we rebuild the container and install those dependencies. So to do this we need two things.\n\n1.) We need to add `package.json` to our build triggers list, with an empty hash, like this:\n\n```\nlocal_balenaos:\n  app-name: myapp\n  build-triggers:\n    - Dockerfile: 1327b0f9875d5c4bf7f2f36fad384c8481a00396830acd33c0af0e575648fe91\n    - package.json:\n```\n\nAnd 2.) We then need to run a `npm install` in our build, so we add a few lines to our Dockerfile.\n\n``` Dockerfile\nFROM resin/{{ $device.id }}-alpine-node:slim\nWORKDIR /usr/src/app\nCOPY package.json package.json\nRUN npm install\nCOPY . .\nCMD [\"node\", \"main.js\"]\n```\n\n__NOTE:__ Add `node_modules` to your `.dockerignore` file, otherwise your local modules might be copied to the device with the above `Dockerfile`, and they are likely the wrong architecture for your application!\n\nWe can now deploy our new webserver container again with:\n\n``` bash\n$ sudo balena local push -s .\n```\n\nYou should now be able to point your web browser on your laptop to the IP address of your device and see the \"Hello, World!\" message.\n","jsonml":[["hr"],["hr"],["header",{"level":1},"Getting Started on the {{ $device.name }}"],["para","In balenaOS all application logic and services are encapsulated in Docker containers. In this getting started guide we will walk you through setting up one of our pre-built development OS images and creating a simple application container. In the guide we will use the ",["inlinecode","balena"]," CLI tool to make things super easy. However, for those that like to do things the hard way, we got you covered as well."],["header",{"level":2},"Download an Image"],["para","To get a balenaOS device setup, we will first need to flash a system image on to the device, so head over to ",["link",{"href":"https://balena.io/os"},"balena.io/os"]," and grab the development OS for your board. Currently balenaOS supports 20 different boards and several different architectures. See the ",["link",{"href":"/docs/supportedboards/"},"Supported Boards"]," section for more details."],["para","Once the download is finished, make sure to decompress it and keep it somewhere safe, we will need it very soon!\n",["inlinecode"," bash\n$ wget {{ $device.download_url }}\n"]],["header",{"level":2},"Install the Balena CLI"],["para","The balena cli, is a collection of utilities which helps us to develop balenaOS based application containers. It’s not strictly necessary, but makes life so so much sweeter, but if you like doing things the hard way, skip over to the next section."],["para","Currently the CLI is a node.js based command line tool which requires that our system has the following dependencies installed and in our path:"],["bulletlist",["listitem",["link",{"href":"https://nodejs.org/en/"},"node.js 6.x"]],["listitem",["link",{"href":"https://www.npmjs.com/"},"npm package manager"]],["listitem",["link",{"href":"https://download.samba.org/pub/rsync/rsync.html"},"rsync"]],["listitem",["link",{"href":"http://www.openssh.com/"},"ssh"]]],["para","Once we have those setup we can install ",["inlinecode","balena"]," CLI using npm:\n",["inlinecode"," bash\n$ npm install --global --production --unsafe-perm balena-cli\n"]],["para",["strong","Note:"]," Depending on you node.js installation, you may need to use administrative privileges to install the CLI."],["header",{"level":2},"Configure the Image"],["para","To allow balenaOS images to be easily configurable before boot, some key config files are added to boot partition. In this step we will use the CLI to configure the network, set our hostname to ",["inlinecode","balena"]," and disable persistent logging, because we don’t want to kill our poor flash storage with excessive writes.\n",["inlinecode"," bash\n$ sudo balena local configure ~/Downloads/balena.img\n? Network SSID super_wifi\n? Network Key super secure password\n? Do you want to set advanced settings? Yes\n? Device Hostname balena\n? Do you want to enable persistent logging? no\nDone!\n"]],["para","If you are not using the balena CLI, you will need to mount the boot partition of the image and edit the configuration manually."],["para","Edit ",["inlinecode","/boot/config.json"]," so it looks like this:\n",["inlinecode"," json\n{\n  \"persistentLogging\": false,\n  \"hostname\": \"balena\",\n}\n"]],["para","And edit the ",["inlinecode","ssid"]," and ",["inlinecode","psk"]," values in the ",["inlinecode","/boot/system-connections/resin-sample"]," connection file.\n",["inlinecode",""],"`\n",["link_ref",{"ref":"connection","original":"[connection]"},"connection"],"\nid=balena-sample\ntype=wifi"],["para",["link_ref",{"ref":"wifi","original":"[wifi]"},"wifi"],"\nmode=infrastructure\nssid=I",["em","Love"],"Unicorns"],["para",["link_ref",{"ref":"wifi-security","original":"[wifi-security]"},"wifi-security"],"\nauth-alg=open\nkey-mgmt=wpa-psk\npsk=superSecretPassword"],["para",["link_ref",{"ref":"ipv4","original":"[ipv4]"},"ipv4"],"\nmethod=auto"],["para",["link_ref",{"ref":"ipv6","original":"[ipv6]"},"ipv6"],"\naddr-gen-mode=stable-privacy\nmethod=auto\n",["inlinecode",""],"`"],["para","If you only want to use an ethernet connection on your device, you don't need to add anything. The device will automatically set up an ethernet connection by default."],["header",{"level":2},"Get the Device Up and Running"],["para","Okay, so now we have a fully configured image ready to go, so let’s burn and boot this baby. For this step the CLI provides a handy flashing utility, you can however flash this image using etcher.io or ",["inlinecode","dd"]," if you must."],["header",{"level":3},"Flash {{ $device.bootMedia }}"],["para","To get flashing, just point the ",["inlinecode","balena local flash"]," command to the image we just downloaded and follow the prompts. If you hate prompts, the CLI also allows you to skip them, check the ",["link",{"href":"https://balena.io/docs/architecture/#balena-command-line-tool"},"balena CLI docs"]," on how to do this."],["para",["strong","NOTE:"]," ",["inlinecode","balena local flash"]," requires administrative privileges because it needs to access the {{ $device.bootMedia }}."],["para",["inlinecode"," bash\n$ sudo balena local flash ~/Downloads/balena.img\nPassword:\nx No available drives were detected, plug one in!\n"]],["para","Once you plug in your {{ $device.bootMedia }}, the CLI should detect it and show you the following selection dialog. Make sure to select the correct drive if you have a few listed, as this will completely write over the drive."],["para",["inlinecode"," bash\n$ sudo balena local flash ~/Downloads/balena.img\nPassword:\n? Select drive (Use arrow keys)\n❯ /dev/disk3 (7.9 GB) - STORAGE DEVICE\n"]],["para","Once you are happy you have selected the correct drive, hit enter and wait while your new OS is written to the drive.\nIt should only take about 3 minutes, depending on the quality of your drive, so this is a great time to go grab a caffeinated beverage."],["para",["inlinecode"," bash\n$ sudo balena local flash ~/Downloads/balena.img\n? Select drive /dev/disk3 (7.9 GB) - STORAGE DEVICE\n? This will erase the selected drive. Are you sure? Yes\nFlashing [========================] 100% eta 0s  \nValidating [========================] 100% eta 0s\n"]],["para",["strong","Note:"]," Remember to safely remove your {{ $device.bootMedia }} before pulling it out."],["header",{"level":3},"Boot the device"],["para","{{ import \"bootdevice\" }}"],["para","After about 30 seconds or so your device should be up and connected to your local network, you should see it broadcasting itself as ",["inlinecode","balena.local"],". To check this, let’s try ping the device."],["para",["inlinecode"," bash\n$ ping balena.local\nPING 192.168.1.111 (192.168.1.111): 56 data bytes\n64 bytes from 192.168.1.111: icmp_seq=0 ttl=64 time=103.674 ms\n64 bytes from 192.168.1.111: icmp_seq=1 ttl=64 time=9.723 ms\n^C\n--- 192.168.1.111 ping statistics ---\n6 packets transmitted, 6 packets received, 0.0% packet loss\nround-trip min/avg/max/stddev = 7.378/24.032/103.674/35.626 ms\n"]],["para","Now if we want to poke around a bit inside balenaOS we can just ssh in with:\n",["inlinecode"," bash\n$ ssh root@balena.local -p22222\nroot@balena:~# uname -a\nLinux balena 4.1.21 #1 SMP Fri Oct 7 23:37:01 CEST 2016 armv7l GNU/Linux\nroot@balena:~# balena info\nContainers: 1\n Running: 0\n Paused: 0\n Stopped: 1\nImages: 7\nServer Version: 1.10.3\nStorage Driver: aufs\n Root Dir: /var/lib/balena/aufs\n Backing Filesystem: extfs\n Dirs: 22\n Dirperm1 Supported: true\nExecution Driver: native-0.2\nLogging Driver: journald\nPlugins:\n Volume: local\n Network: null host bridge\nKernel Version: 4.1.21\nOperating System: Balena OS 1.16.1\nOSType: linux\nArchitecture: armv7l\nCPUs: 4\nTotal Memory: 972.5 MiB\nName: balena\nID: FOZ2:5KHG:RTSS:UQ7S:F2J6:QYLL:MERX:5ZVU:4WVL:3G2G:T2YA:LX3D\n"]],["para",["strong","Note:"]," Beginning with version 2.9.0, balenaOS uses the ",["link",{"href":"https://www.balena.io/"},"balena"]," container engine to manage Docker containers. If you are using an earlier version of the OS, replace ",["inlinecode","balena"]," commands with ",["inlinecode","docker"],"."],["header",{"level":2},"Running your first Container"],["header",{"level":3},"Clone a demo Project"],["para","{{#eq $device.id \"nuc\"}}\n",["inlinecode"," bash\n$ git clone https://github.com/balena-io-playground/balenaos-sample-x86\n"],"\n{{else}}\n",["inlinecode"," bash\n$ git clone https://github.com/balena-io-playground/balenaos-sample\n"],"\n{{/eq}}"],["header",{"level":3},"Get a Container Running"],["para",["inlinecode"," bash\n$ sudo balena local push balena.local --source .\n"],"\nThis command will use the image specified by the ",["inlinecode","Dockerfile"]," in the root of your project directory (--source specifies where to find your project). The build of this image will happen on your balenaOS device and once completed, the command will start up a container from that newly built image. For more details look at the ",["link",{"href":"#creating-a-project-from-scratch"},"Creating a Project from Scratch"]," section below."],["header",{"level":2},"Poking Around balenaOS"],["para","To help explore balenaOS devices and application containers more easily, the balena CLI has an ssh command which will help you connect either to the HostOS or a running container on the device."],["header",{"level":4},"To ssh into the host:"],["para",["inlinecode"," bash\n$ sudo balena local ssh --host\n"],"\n",["strong","OR"],"\n",["inlinecode"," bash\n$ ssh root@balena.local -p22222\n"]],["header",{"level":4},"To ssh into a particular container:"],["para",["inlinecode"," bash\n$ sudo balena local ssh balena.local\n"],"\n",["strong","OR"],"\n",["inlinecode"," bash\n$ ssh root@balena.local -p22222\nroot@balena:~# balena exec -it myapp bash\n"]],["header",{"level":2},"Going Further"],["header",{"level":3},"Advanced Settings"],["para","Either mount the {{ $device.bootMedia }} and run:\n",["inlinecode"," bash\n$ sudo balena local configure /path/to/drive\n"],"\nAnd select ",["inlinecode","y"]," when asked if you want to add advanced settings."],["para","Alternatively you can add ",["inlinecode","“persistentLogging”: true"]," to ",["inlinecode","config.json"]," in your boot partition of the {{ $device.bootMedia }}."],["para","To Enable persistent logs in a running device, add ",["inlinecode","“persistentLogging”: true"]," to ",["inlinecode","/mnt/boot/config.json"]," and reboot."],["para","The journal can be found at  ",["inlinecode","/var/log/journal/"]," which is bind mounted to ",["inlinecode","root-overlay/var/log/journal"]," in the ",["inlinecode","resin-state"]," partition.\nWhen logging is not persistent, the logs can be found at ",["inlinecode","/run/log/journal/"]," and this log is volatile so you will loose all logs when you power the device down."],["header",{"level":2},"Creating a Project from Scratch"],["para","Alright! So we have an awesome container machine up and running on our network. So let’s start pushing some application containers onto it. In this section we will do a quick walk through of setting up a ",["inlinecode","Dockerfile"]," and make a simple little node.js webserver."],["para","To get started, let’s create a new project directory called “myapp” and create a new file called ",["inlinecode","Dockerfile"],"."],["para",["inlinecode"," bash\n$ mkdir -p myapp && touch Dockerfile\n"]],["para","Now we will create a minimal node.js container based on the slim ",["link",{"href":"link-to-alpine"},"Alpine Linux distro"],". We do this by adding the following lines to our Dockerfile."],["para",["inlinecode"," Dockerfile\nFROM resin/{{ $device.id }}-alpine-node:slim\nCMD [“cat”, “/etc/os-release”]\n"]],["para","The ",["inlinecode","FROM"]," tells Docker what our container will be based on. In this case an Alpine Linux userspace with just the bare essentials needed for the node.js runtime. The ",["inlinecode","CMD"]," just defines what our container runs on startup. In this case, it’s not very exciting yet."],["para","Now to get our application running on our device we can use the ",["inlinecode","balena local push"]," functionality.\n",["inlinecode",""],"`bash\n$ sudo balena local push balena.local --source .\n* Building..\n- Stopping and Removing any previous 'myapp' container\n- Removing any existing container images for 'myapp'\n- Building new 'myapp' image\nStep 1 : FROM resin/{{ $device.id }}-alpine-node:slim\nPulling from resin/{{ $device.id }}-alpine-node\nPulling fs layer\nVerifying Checksum=============================================>]     32 B/32 B7 MB\nDownload complete\nVerifying Checksum=============================================>] 1.987 MB/1.987 MB\nPull complete=================================================>]    12 MB/12 MB\nPull complete\nDigest: sha256:410a5add3aa281d97afea1ae4fcdbec203c69ea34faea8d84349456c211f33a3\nStatus: Downloaded newer image for resin/{{ $device.id }}-alpine-node:slim\n ---> bf37b6350e63\nStep 2 : CMD ",["link_ref",{"ref":"“cat”, “/etc/os-release”","original":"[“cat”, “/etc/os-release”]"},"“cat”, “/etc/os-release”"],"\n ---> Running in a376f4a781d5\n ---> a3c2c42b1212\nRemoving intermediate container a376f4a781d5\nSuccessfully built a3c2c42b1212\n- Creating 'myapp' container\n- Starting 'myapp' container"],["para","balena push completed successfully!\n",["inlinecode",""],"`"],["para","This command will discover your balenaOS-dev device on the network and start a build of whatever you have in the ",["inlinecode","--source"]," directory. In the example above, we have just told it to build from the root of the directory we are in, in this case ",["inlinecode","myapp"],"."],["para","A number of things have happened in this step, so let’s pause here and dig in a little more. When we first run ",["inlinecode","balena local push"]," we are asked to define a name for our app and after that, it starts a Docker build on your device. At the same time, the CLI has added a file to our project called ",["inlinecode",".resin-sync.yml"]," which stores all the project defaults. Let’s have a quick look at that:"],["para",["inlinecode"," yaml\nlocal_balenaos:\n  app-name: myapp\n  build-triggers:\n    - Dockerfile: 6275495dc9620c3c74aa5a25ef29bbb109fbcb4e46de941b14235aeea02cc184\n"]],["para","We can see that for our local balenaOS device we have an app called “myapp” which will map over to a Docker image and container on our device. The next interesting section is build-triggers. This is a list of files and their hashes, which will result in a Docker build. In our case it’s just the ",["inlinecode","Dockerfile"],", so when we change things here, the CLI will rebuild our app. This will be important a bit later."],["para","So now that we are building, let’s start adding some actual code! We will just add ",["inlinecode","main.js"]," file in the root of our ",["inlinecode","myapp"]," directory."],["para",["inlinecode"," javascript\n//main.js\nconsole.log(\"Hey… I’m a node.js app running in a container!!\");\n"]],["para","We then make sure our Dockerfile copies this source file into our container context by replacing our current ",["inlinecode","CMD [“cat”,”/etc/os-release”]"]," in our Dockerfile with the following."],["para",["inlinecode"," Dockerfile\nFROM resin/{{ $device.id }}-alpine-node:slim\nWORKDIR /usr/src/app\nCOPY . .\nCMD [\"node\", \"main.js\"]\n"]],["para","This puts all the contents of our ",["inlinecode","myapp"]," directory into ",["inlinecode","/usr/src/app"]," in our running container and says we should start main.js when the container starts."],["para","Alright, so we have a simple javascript container, but that’s pretty boring, let’s add some dependencies and complexity.  To add dependencies in node.js we need a package.json, the easiest way to whip up one is to just run ",["inlinecode","npm init"]," in the root of our ",["inlinecode","myapp"]," directory. After a nice little interactive dialog we have the following ",["inlinecode","package.json"]," in directory."],["para",["inlinecode"," json\n{\n  \"name\": \"myapp\",\n  \"version\": \"1.0.0\",\n  \"description\": \"a simple hello world webserver\",\n  \"main\": \"main.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"no tests yet\\\"\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"none\"\n  },\n  \"author\": \"Shaun Mulligan <shaun@balena.io>\",\n  \"license\": \"ISC\"\n}\n"]],["para","Now it’s time to add some dependencies. For our little webserver, we will use the popular expressjs module. We can add it to the ",["inlinecode","package.json"]," after the ",["inlinecode","\"license\": \"ISC\""],", so it now looks like this:"],["para",["inlinecode"," json\n{\n  \"name\": \"myapp\",\n  \"version\": \"1.0.0\",\n  \"description\": \"a simple hello world webserver\",\n  \"main\": \"main.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"no tests yet\\\"\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"none\"\n  },\n  \"author\": \"Shaun Mulligan <shaun@balena.io>\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"express\": \"^4.14.0\"\n  }\n}\n"]],["para","Now all we need to do is add a few more lines of javacript to our main.js and we are off to the races."],["para",["inlinecode",""],"` javascript\n//main.js"],["para","var express = require('express');\nvar app = express();"],["para","// reply to request with \"Hello World!\"\napp.get('/', function (req, res) {\n  res.send(\"Hello World, I'm a container running on balenaOS!\");\n});"],["para","//start a server on port 80 and log its start to our console\nvar server = app.listen(80, function () {"],["para","  var port = server.address().port;\n  console.log(\"Hey… I’m a node.js server running in a container and listening on port: \", port);\n});\n",["inlinecode",""],"`"],["para","Great, so now we are almost ready to go, but we want to make sure anytime we add a dependency to our ",["inlinecode","package.json"]," that we rebuild the container and install those dependencies. So to do this we need two things."],["para","1.) We need to add ",["inlinecode","package.json"]," to our build triggers list, with an empty hash, like this:"],["para",["inlinecode","\nlocal_balenaos:\n  app-name: myapp\n  build-triggers:\n    - Dockerfile: 1327b0f9875d5c4bf7f2f36fad384c8481a00396830acd33c0af0e575648fe91\n    - package.json:\n"]],["para","And 2.) We then need to run a ",["inlinecode","npm install"]," in our build, so we add a few lines to our Dockerfile."],["para",["inlinecode"," Dockerfile\nFROM resin/{{ $device.id }}-alpine-node:slim\nWORKDIR /usr/src/app\nCOPY package.json package.json\nRUN npm install\nCOPY . .\nCMD [\"node\", \"main.js\"]\n"]],["para",["strong","NOTE:"]," Add ",["inlinecode","node_modules"]," to your ",["inlinecode",".dockerignore"]," file, otherwise your local modules might be copied to the device with the above ",["inlinecode","Dockerfile"],", and they are likely the wrong architecture for your application!"],["para","We can now deploy our new webserver container again with:"],["para",["inlinecode"," bash\n$ sudo balena local push -s .\n"]],["para","You should now be able to point your web browser on your laptop to the IP address of your device and see the \"Hello, World!\" message."]]}},{"filename":"docs/index.md","mime":"text/markdown","data":{"markdown":"---\ntitle: Introduction\n---\n\n## What is balenaOS?\n\nBalenaOS has been designed to include the minimal set of required components to reliably support operation of the Docker engine in embedded scenarios.\nIt uses the Yocto framework as a foundation, systemd as the init system.\n\nThe networking stack consists of Network Manager, DNSmasq and Modem Manager. We have found these components to be a robust stack for dealing with the diversity\nof hardware and unpredictability of configuration of networks in which a device may be booted.\n\nIn addition, we include Avahi, Dropbear, and OpenVPN, which add support for mDNS, SSH, and VPN connections respectively.\n\nThis foundation is uniquely suited to running arbitrary containers on a wide range of embedded devices which balenaOS supports.\nBalena has also made available a wide selection of base images for containers which are optimised for the same scenario and allow developers to create\napplications based on the Debian, Alpine, or Fedora distributions. That is not to say, of course, that any other container base image may not be used,\nbut that the images by balena have been verified to work well with balenaOS, implementing patterns which are particularly suitable for embedded devices, like balenaOS itself.\n\n<img src=\"/images/docs/arch/balenaos-stack.png\" width=\"80%\">\n","jsonml":[["hr"],["hr"],["header",{"level":2},"What is balenaOS?"],["para","BalenaOS has been designed to include the minimal set of required components to reliably support operation of the Docker engine in embedded scenarios.\nIt uses the Yocto framework as a foundation, systemd as the init system."],["para","The networking stack consists of Network Manager, DNSmasq and Modem Manager. We have found these components to be a robust stack for dealing with the diversity\nof hardware and unpredictability of configuration of networks in which a device may be booted."],["para","In addition, we include Avahi, Dropbear, and OpenVPN, which add support for mDNS, SSH, and VPN connections respectively."],["para","This foundation is uniquely suited to running arbitrary containers on a wide range of embedded devices which balenaOS supports.\nBalena has also made available a wide selection of base images for containers which are optimised for the same scenario and allow developers to create\napplications based on the Debian, Alpine, or Fedora distributions. That is not to say, of course, that any other container base image may not be used,\nbut that the images by balena have been verified to work well with balenaOS, implementing patterns which are particularly suitable for embedded devices, like balenaOS itself."],["para","<img src=\"/images/docs/arch/balenaos-stack.png\" width=\"80%\">"]]}},{"filename":"docs/supportedboards.md","mime":"text/markdown","title":"Supported Boards","data":{"markdown":"---\ntitle: Supported Architectures\nlayout: docs.html\n---\n\n# Supported Boards\n\n## ARMv7\n| Device                      | Link                                                                         | BalenaOS Repo                                    |\n|-----------------------------|------------------------------------------------------------------------------|--------------------------------------------------|\n| Raspberry Pi 3 Model B      | https://www.raspberrypi.org/products/raspberry-pi-3-model-b/                 | https://github.com/balena-os/balena-raspberrypi  |\n| Raspberry Pi 2 Model B      | https://www.raspberrypi.org/products/raspberry-pi-2-model-b/                 | https://github.com/balena-os/balena-raspberrypi  |\n| Beaglebone Black            | http://beagleboard.org/black                                                 | https://github.com/balena-os/balena-beaglebone   |\n| Beaglebone Green            | http://beagleboard.org/green                                                 | https://github.com/balena-os/balena-beaglebone   |\n| Beaglebone Green Wireless   | http://beagleboard.org/green-wireless                                        | https://github.com/balena-os/balena-beaglebone   |\n| Samsung Artik 5             | https://www.artik.io/modules/overview/artik-5/                               | https://github.com/balena-os/balena-artik        |\n| Samsung Artik 10            | https://www.artik.io/modules/overview/artik-10/                              | https://github.com/balena-os/balena-artik        |\n| Odroid C1/C1+               | http://www.hardkernel.com/main/products/prdt_info.php?g_code=G141578608433   | https://github.com/balena-os/balena-odroid       |\n| Odroid XU4                  | http://www.hardkernel.com/main/products/prdt_info.php?g_code=G143452239825   | https://github.com/balena-os/balena-odroid       |\n| SolidRun HummingBoard-base  | https://www.solid-run.com/product/hummingboard-carrier-base/                 | https://github.com/balena-os/balena-fsl-arm      |\n| Boundary Devices Nitrogen6X | https://boundarydevices.com/product/nitrogen6x-board-imx6-arm-cortex-a9-sbc/ | https://github.com/balena-os/balena-fsl-arm      |\n| Parallella Board            | https://www.parallella.org/board/                                            | https://github.com/balena-os/balena-parallella   |\n| VIA vab820                  | http://www.viatech.com/en/boards/pico-itx/vab-820/                           | https://github.com/balena-os/balena-fsl-arm      |\n\n## ARMv6\n| Device                      | Link                                                                         | BalenaOS Repo                                    |\n|-----------------------------|------------------------------------------------------------------------------|--------------------------------------------------|\n| Raspberry Pi 1 Model A+     | https://www.raspberrypi.org/products/model-a-plus/                           | https://github.com/balena-os/balena-raspberrypi  |\n| Raspberry Pi ZERO           | https://www.raspberrypi.org/products/pi-zero/                                | https://github.com/balena-os/balena-raspberrypi  |\n\n## ARMv5\n| Device                      | Link                                                                         | BalenaOS Repo                                    |\n|-----------------------------|------------------------------------------------------------------------------|--------------------------------------------------|\n| Technologic Systems TS-7700 | http://wiki.embeddedarm.com/wiki/TS-7700                                     | https://github.com/balena-os/balena-ts           |\n\n## Intel x86_32\n| Device                      | Link                                                                         | BalenaOS Repo                                    |\n|-----------------------------|------------------------------------------------------------------------------|--------------------------------------------------|\n| Intel Edison                | http://www.intel.com/content/www/us/en/do-it-yourself/edison.html            | https://github.com/balena-os/balena-edison       |\n\n## Intel x86_64\n| Device                      | Link                                                                         | BalenaOS Repo                                    |\n|-----------------------------|------------------------------------------------------------------------------|--------------------------------------------------|\n| Intel NUC                   | http://www.intel.co.uk/content/www/uk/en/nuc/overview.html                   | https://github.com/balena-os/balena-intel        |\n","jsonml":[["hr"],["hr"],["header",{"level":1},"Supported Boards"],["header",{"level":2},"ARMv7"],["para","| Device                      | Link                                                                         | BalenaOS Repo                                    |\n|-----------------------------|------------------------------------------------------------------------------|--------------------------------------------------|\n| Raspberry Pi 3 Model B      | https://www.raspberrypi.org/products/raspberry-pi-3-model-b/                 | https://github.com/balena-os/balena-raspberrypi  |\n| Raspberry Pi 2 Model B      | https://www.raspberrypi.org/products/raspberry-pi-2-model-b/                 | https://github.com/balena-os/balena-raspberrypi  |\n| Beaglebone Black            | http://beagleboard.org/black                                                 | https://github.com/balena-os/balena-beaglebone   |\n| Beaglebone Green            | http://beagleboard.org/green                                                 | https://github.com/balena-os/balena-beaglebone   |\n| Beaglebone Green Wireless   | http://beagleboard.org/green-wireless                                        | https://github.com/balena-os/balena-beaglebone   |\n| Samsung Artik 5             | https://www.artik.io/modules/overview/artik-5/                               | https://github.com/balena-os/balena-artik        |\n| Samsung Artik 10            | https://www.artik.io/modules/overview/artik-10/                              | https://github.com/balena-os/balena-artik        |\n| Odroid C1/C1+               | http://www.hardkernel.com/main/products/prdt",["em","info.php?g"],"code=G141578608433   | https://github.com/balena-os/balena-odroid       |\n| Odroid XU4                  | http://www.hardkernel.com/main/products/prdt",["em","info.php?g"],"code=G143452239825   | https://github.com/balena-os/balena-odroid       |\n| SolidRun HummingBoard-base  | https://www.solid-run.com/product/hummingboard-carrier-base/                 | https://github.com/balena-os/balena-fsl-arm      |\n| Boundary Devices Nitrogen6X | https://boundarydevices.com/product/nitrogen6x-board-imx6-arm-cortex-a9-sbc/ | https://github.com/balena-os/balena-fsl-arm      |\n| Parallella Board            | https://www.parallella.org/board/                                            | https://github.com/balena-os/balena-parallella   |\n| VIA vab820                  | http://www.viatech.com/en/boards/pico-itx/vab-820/                           | https://github.com/balena-os/balena-fsl-arm      |"],["header",{"level":2},"ARMv6"],["para","| Device                      | Link                                                                         | BalenaOS Repo                                    |\n|-----------------------------|------------------------------------------------------------------------------|--------------------------------------------------|\n| Raspberry Pi 1 Model A+     | https://www.raspberrypi.org/products/model-a-plus/                           | https://github.com/balena-os/balena-raspberrypi  |\n| Raspberry Pi ZERO           | https://www.raspberrypi.org/products/pi-zero/                                | https://github.com/balena-os/balena-raspberrypi  |"],["header",{"level":2},"ARMv5"],["para","| Device                      | Link                                                                         | BalenaOS Repo                                    |\n|-----------------------------|------------------------------------------------------------------------------|--------------------------------------------------|\n| Technologic Systems TS-7700 | http://wiki.embeddedarm.com/wiki/TS-7700                                     | https://github.com/balena-os/balena-ts           |"],["header",{"level":2},"Intel x86_32"],["para","| Device                      | Link                                                                         | BalenaOS Repo                                    |\n|-----------------------------|------------------------------------------------------------------------------|--------------------------------------------------|\n| Intel Edison                | http://www.intel.com/content/www/us/en/do-it-yourself/edison.html            | https://github.com/balena-os/balena-edison       |"],["header",{"level":2},"Intel x86_64"],["para","| Device                      | Link                                                                         | BalenaOS Repo                                    |\n|-----------------------------|------------------------------------------------------------------------------|--------------------------------------------------|\n| Intel NUC                   | http://www.intel.co.uk/content/www/uk/en/nuc/overview.html                   | https://github.com/balena-os/balena-intel        |"]]}}]}},"github":{"public":true,"fork":false,"stars":99,"owner":{"handle":"balena-os","type":"Organization","name":"balena-os","description":"Balena brings the benefits of Linux containers to the IoT. Develop iteratively, deploy safely, and manage at scale.","url":"https://github.com/balena-os","email":"hello@balena.io","avatar":"https://avatars2.githubusercontent.com/u/16914061?v=4"},"usedBy":""},"contributors":[{"username":"shaunmulligan","avatar":"https://avatars1.githubusercontent.com/u/3915043?v=4","contributions":27},{"username":"lurch","avatar":"https://avatars2.githubusercontent.com/u/476186?v=4","contributions":14},{"username":"LucianBuzzo","avatar":"https://avatars0.githubusercontent.com/u/15064535?v=4","contributions":8},{"username":"imrehg","avatar":"https://avatars0.githubusercontent.com/u/38863?v=4","contributions":6},{"username":"chrisys","avatar":"https://avatars0.githubusercontent.com/u/521698?v=4","contributions":4},{"username":"xginn8","avatar":"https://avatars1.githubusercontent.com/u/6697261?v=4","contributions":4},{"username":"kennethlimcp","avatar":"https://avatars1.githubusercontent.com/u/6760914?v=4","contributions":3},{"username":"Page-","avatar":"https://avatars3.githubusercontent.com/u/360115?v=4","contributions":3},{"username":"emirotin","avatar":"https://avatars0.githubusercontent.com/u/525832?v=4","contributions":2},{"username":"fboudra","avatar":"https://avatars0.githubusercontent.com/u/2629526?v=4","contributions":2},{"username":"jhermsmeier","avatar":"https://avatars3.githubusercontent.com/u/244907?v=4","contributions":2},{"username":"petrosagg","avatar":"https://avatars3.githubusercontent.com/u/939420?v=4","contributions":2},{"username":"zwalchuk","avatar":"https://avatars0.githubusercontent.com/u/8054407?v=4","contributions":2},{"username":"ZubairLK","avatar":"https://avatars0.githubusercontent.com/u/3186710?v=4","contributions":2},{"username":"dimitrisnl","avatar":"https://avatars2.githubusercontent.com/u/4951004?v=4","contributions":1},{"username":"gmacario","avatar":"https://avatars2.githubusercontent.com/u/75182?v=4","contributions":1},{"username":"thgreasi","avatar":"https://avatars0.githubusercontent.com/u/1295829?v=4","contributions":1},{"username":"pimterry","avatar":"https://avatars0.githubusercontent.com/u/1526883?v=4","contributions":1},{"username":"tvi","avatar":"https://avatars2.githubusercontent.com/u/739690?v=4","contributions":1},{"username":"willnewton","avatar":"https://avatars3.githubusercontent.com/u/93721?v=4","contributions":1}],"releases":{"latestRelease":null,"latestPreRelease":null}}}